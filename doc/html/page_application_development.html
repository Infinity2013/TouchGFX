<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TouchGFX: Application Development</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="touchgfx.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="touchgfxlogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TouchGFX
   &#160;<span id="projectnumber">v4.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_application_development.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Application Development </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes the key points of TouchGFX application development. New to TouchGFX? If so, you will most likely find the initial sections that follow this introduction useful as they outline the basics of application development:</p>
<ol type="1">
<li><a class="el" href="page_application_development.html#sect_application_development_app_file_structure">Application File Structure</a> detailing the contents of a standard TouchGFX application</li>
<li><a class="el" href="page_application_development.html#sect_application_development_assets">Application assets</a> and their role in application development</li>
</ol>
<p>To get you started on application development, here is a common development scenario:</p>
<ol type="1">
<li><a class="el" href="page_application_development.html#sect_application_development_creating_new_app">Creating a New Application</a> Shows you how to create a new application and shows you how to configure the location of your TouchGFX framework installation relative to the location of your application.</li>
<li><a class="el" href="page_application_development.html#sect_application_development_project_conf">Project Configuration</a> goes through the various application specific settings available to developers</li>
<li><a class="el" href="page_examples.html">Examples</a> offers insight into how to construct simple applications with the standard TouchGFX widget library such as buttons, transitions, lists, texts, containers etc.</li>
</ol>
<p>If you feel ready to go further than introductory application development:</p>
<ol type="1">
<li><a class="el" href="page_application_development.html#sect_application_development_concepts">Concepts</a> talks about events, memory allocation, custom widgets and containers, and how to use texts, fonts and images.</li>
<li><a class="el" href="page_application_development.html#sect_application_development_misc">Miscellaneous</a> covers minor topics and tips and tricks.</li>
</ol>
<h1><a class="anchor" id="sect_application_development_app_file_structure"></a>
Application File Structure</h1>
<p>As a general rule, the application examples provided with TouchGFX are not a part of the actual TouchGFX framework, but are simply provided as part of the distribution. By default, an application in TouchGFX conforms to the following folder structure which is natively supported by the build configurations in the distribution. Deviating from this folder structure without modifications to the build configurations provided by TouchGFX can potentially cause build-errors.</p>
<pre class="fragment">+-- assets
|   +-- fonts
|   +-- images
|   \-- texts
| 
+-- config
|   +-- gcc
|   \-- msvs  
|
+-- generated
|   +-- fonts
|   +-- images
|   \-- texts
|
+-- gui
+-- platform 
+-- simulator
\-- target 
</pre><h2><a class="anchor" id="sect_application_development_assets"></a>
Application assets</h2>
<p>Typically, an application makes use of a number of image, font and textual <em>assets</em>. By convention, asset files should be placed by the user in their respective folders in <code>assets</code> of the root of an applications folder. The Font-, Image- and Textconversion tools of TouchGFX expect assets to conform to this guideline and any assets not located in the appropriate folder will either not be processed, or cause a failure during conversion.</p>
<p>A prerequisite to successful compilation of either of the supplied applications in TouchGFX is code generation for the applications assets: <em>images</em>, <em>fonts</em>, <em>texts</em>.</p>
<p>Any code generated by these converter tools is placed in the folder <code>generated</code>, mirroring the structure of the <code>assets</code> folder. For generated application assets only, the folder structure is as seen below. </p><pre class="fragment">+-- generated
|   +-- fonts
|   |   +-- include 
:   :   \-- src
:   :
</pre><p><br />
 Notice, contrary to the rest of the framework, that the <code>fonts</code> folder (and also <code>images</code> and <code>texts</code>) is a self contained component with source code and header files that must be added to the list of include directories for a build configuration that wishes to use it. This allows you to place these <em>application specific</em> components, where ever you desire as long as you make sure to modify your build configuration. If you inspect any of our IAR build configurations you would see the following include folders related to assets (similar for Keil uVision).</p>
<pre class="fragment">$PROJ_DIR$\..\..\..\..\generated\fonts\include
$PROJ_DIR$\..\..\..\..\generated\images\include
$PROJ_DIR$\..\..\..\..\generated\texts\include
</pre><p> <br />
 </p>
<h3><a class="anchor" id="sect_application_development_assets_Fonts"></a>
Font assets</h3>
<p>Font assets are located in the folder <code>assets/fonts/</code>. When compiling an application, the Font Converter will convert these font assets to source code, which is output to the <code>generated/fonts</code> directory. See <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_fonts">Font Converter</a> for details on fonts and texts.</p>
<h3><a class="anchor" id="sect_application_development_assets_images"></a>
Image assets</h3>
<p>Image assets are located in the folder <code>assets/images</code>. When compiling an application, the Image Converter will convert the image assets to source code, which is output to the <code>generated/images</code> directory. When this code is a part of project, images are made available to application developers through an identifier based on the original file name of the asset. For details on how images are converted and how to use images in the source code of your application, see <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_images">Image Converter</a>. Also be sure to have a look at the <a class="el" href="page_examples.html">Examples</a>, which all use bitmap graphics.</p>
<h3><a class="anchor" id="sect_application_development_assets_texts"></a>
Text assets</h3>
<p>TouchGFX provides an easy way of defining text strings, languages and translations for use in applications. The <code>assets/texts</code> folder contains an Excel spreadsheet called <code>texts.xlsx</code> containing text definitions for a specific application. Source code based on these definitions is generated to the <code>generated/texts</code> directory by the TouchGFX <code>Text</code> Converter. See <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_texts">Text Converter</a> for details on using texts in your application, as well as the <a class="el" href="page_examples.html#sect_text_example">Text Example</a> for a concrete example of using texts and translations in an application.</p>
<h2><a class="anchor" id="sect_application_development_config"></a>
Application configuration</h2>
<p>The files in the <code>config</code> folder contain <em>user defined</em> and application specific settings that used as input to the TouchGFX build environment for various compilers (currently available for Microsoft Visual Studio and GCC). Please see <a class="el" href="page_application_development.html#sect_application_development_project_conf">Project Configuration</a> for further details on choosing the settings for your build/project to, among other things, achieve optimized target performance.</p>
<h2><a class="anchor" id="sect_application_development_gui"></a>
Graphical User Interface</h2>
<p>The <code>gui</code> folder of any application provided by TouchGFX contains files related to the graphical user interface. TouchGFX requires knowledge, at compile-time, about the amount of RAM a user interface is going to use up. Such a memory allocation scheme (See <a class="el" href="page_application_development.html#sect_application_development_malloc">Memory Allocation</a>) is conveniently provided by TouchGFX in the form of a well defined architectural pattern helpful in constructing applications with graphical user interfaces (See <a class="el" href="page_application_development.html#sect_application_development_mvp">Model-View-Presenter</a>). The main concepts of this architecture are:</p>
<ul>
<li>The <code>model</code> is an interface defining what data should be presented or acted upon.</li>
<li>The <code>view</code> is a passive interface that displays data from the model and routes events (i.e. user commands) to the presenter.</li>
<li>The <code>presenter</code> acts upon the model and the view. It retrieves data from the model, processes it, and displays it in the view .</li>
</ul>
<p>You'll see that the naming of code files for all applications in TouchGFX take their name according to the above principles. For details on building a graphical interface using the widget library of TouchGFX, see <a class="el" href="page_application_development.html#sect_application_development_concepts">Concepts</a>.</p>
<h2><a class="anchor" id="sect_application_development_platform"></a>
Platform Configuration</h2>
<p>Any common files related to a target platform, such as operating systems configurations are, by convention, placed by TouchGFX in the <code>platform</code> folder. We provide an optional and free operating system <a href="http://www.freertos.org/">FreeRTOS</a> (See <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_os">RT Operating System (touchgfx/os/)</a> on how to replace the standard OS supplied by TouchGFX). The folder <code>platform/os</code> contains the file <code>FreeRTOSConfig.h</code>, located under <code>platform/os</code> is included and used by IAR, Keil and GCC target build configurations throughout the framework. Among other things, the FreeRTOS configuration defines OS stack- and heapsize, hook usage, interrupt priority levels and maps FreeRTOS interrupt handlers to CMSIS standard names.</p>
<h2><a class="anchor" id="sect_application_development_simulator"></a>
PC Simulator</h2>
<p>The folder <code>simulator</code> in any application contains PC simulator build configurations for GCC and Microsoft Visual Studio. See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_simulator">PC Simulator</a> for more on details on how to build and execute simulator applications.</p>
<h2><a class="anchor" id="sect_application_development_target"></a>
Target</h2>
<p>The <code>target</code> folder for any of the supplied sample applications contains build configurations for target hardware that is able to run that particular application which might require certain display dimensions not supported by all targets. As a rule, any graphical user interface code designed for certain display dimensions will run on any board that supports those dimensions if a valid target build configuration for those targets exists. The <code>target</code> folder of the <em>template</em> application called <code>EmptyApplication</code> is an empty shell designed to help people get started on application development and contains build configurations for all demo boards supported by TouchGFX. As such, the example and demo applications provided by TouchGFX do not contain all targets supported by the framework because some of those applications are designed for a specific display resolution. For instance, every example is designed for a 480 x 272 (4.3") resolution. Three supported boards support these dimensions:</p>
<ol type="1">
<li>Embedded Artists LPC4357DevKit</li>
<li>Mjolner TouchGFXDemoBoardRev1.1-4353-4.3</li>
<li>ST STM32429I-EVAL1</li>
</ol>
<p>See <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_board">Board Packages (touchgfx/board/)</a> for an overview of how such target build configurations make use of readily available hardware and software initialization in the shape of what is called <em>board</em> <em>packages</em>.</p>
<h1><a class="anchor" id="sect_application_development_creating_new_app"></a>
Creating a New Application</h1>
<p>The application located under <code>app/template/EmptyApplication</code>, as previously mentioned, is a basic, empty application that can serve as a basis for new applications. It contains build configurations for all of the evaluation boards supported by TouchGFX (IAR, Keil or GCC) and one for for the PC simulator (MinGW or MSVS). While <code>EmptyApplication</code> contains build configurations for every supported evaluation board your choice of compiler might not be supported for that board. For a complete list see <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_files_supported_hardware">Supported Hardware</a>. As a general rule, IAR is supported by all boards, while GCC and Keil support is limited.</p>
<p>Navigate to the template folder from the root of your TouchGFX installation, <code>app/template/</code>. The folder <code>empty_application</code> can be copied, renamed to something suitable and help you get started on application development on PC simulator or any of the supported targets. See <a class="el" href="page_application_development.html#sect_application_development_project_conf">Project Configuration</a> to configure your application relative to your TouchGFX installation folder along with other application specific features.</p>
<pre class="fragment">cp -r empty_application your_application_folder/new_application
</pre><p> <br />
After copying the template application <code>empty_application</code> make sure the TouchGFX framework path in the configuration of the application is correct. To test the application, build the PC simulator:</p>
<pre class="fragment">cd your_application_folder/new_application
make -f simulator/gcc/Makefile
./build/bin/simulator.out
</pre><p> <br />
As for the target configurations supported by the template application, keep in mind that not all targets support the same display dimensions; An application developed for 320x240 QVGA would not look right on a larger screen. So, remember to remove any non-supported targets from the <code>target/</code> folder.</p>
<p>Moving an application around on disk might affect any of the projects projects of an application in that you might need to re-add all files that have changed location on disk. You may also need to update your relative paths the C/C++ and Assembler pre-processors along with references to libraries used by the linker.</p>
<h2><a class="anchor" id="sect_application_development_visual_studio_creation"></a>
Visual Studio Project Creation</h2>
<p>Creating new projects for use with Visual Studio can be handled in almost the same way as the general case.</p>
<ul>
<li>Copy the template application <code>EmptyApplication</code> from the folder <code>app/template/</code>. This will give you a basic Visual Studio solution with a default project.</li>
<li>If you wish, you can rename all the Visual Studio specific files (.sln, vcxproj, .filters) to the name of the new application, e.g. NewApplication</li>
<li>Open the solution and project file, <code>NewApplication.sln</code> and <code>NewApplication.vcxproj</code> in an editor.</li>
<li>Replace all occurrences of TemplateApplication with NewApplication</li>
<li><b>Note</b> : If the NewApplication project is going to be included in solutions with other projects, one should replace the project GUID (found in the project file) in the project and solution files with a newly generated GUID, look for<pre class="fragment">&lt;ProjectGuid&gt;{6E061874-2DC8-4BF4-9B83-12FE838C5E20}&lt;/ProjectGuid&gt;</pre></li>
</ul>
<h3><a class="anchor" id="sect_application_development_visual_studio_complete_project_setup"></a>
Starting from scratch</h3>
<p>Creating an entirely new project in Visual Studio and setting it up to adhere to the TouchGFX standard is also an option:</p>
<ul>
<li>Create an empty, no precompiled header, C++ Win32 console application project</li>
<li>Copy the <code>TemplateApplication.props</code> property sheet to the new project, and add this property sheet to the project using the Property Manager</li>
<li>Add the property sheet found in <code>framework/config/msvs/touchgfx.props</code> to the project using the Property Manager</li>
<li>Add the build customization found in <code>framework/config/msvs/prebuild_touchgfx.targets</code> to the project</li>
<li>Add all *.hpp and *.cpp files (from <code>/gui</code> and <code>/simulator</code>) to the project</li>
<li>Adjust the properties found in the newly added property sheets. The TouchGFXReleasePath should point to where the framework folder is located</li>
<li>Add the assets folder and the images, texts and fonts folder below this</li>
<li><em>Optional</em> Set up filters for header and source files</li>
<li>Build and run</li>
</ul>
<h1><a class="anchor" id="sect_application_development_project_conf"></a>
Project Configuration</h1>
<p>When generated in an appropriate format, image- and textual assets, can greatly enhance the performance of some systems. This section describes how to, among other things, achieve such a performance boost through application configuration. Currently, TouchGFX supports asset generation through <code>gcc</code> and Microsoft Visual Studio projects. Any other supported compiler, such as IAR, have to rely on one of the mentioned compilers for asset generation.</p>
<p>The following table gives you an overview of the possible configuration options for supported compilers.</p>
<table class="doxtable">
<tr>
<th>Property </th><th>Description </th><th>GCC name </th><th>MSVS name  </th></tr>
<tr>
<td><em><b>Framework path</b></em> </td><td>This is a required property to let an application know where to find the TouchGFX installation. <br />
 See <a class="el" href="page_application_development.html#sect_application_development_project_conf">Project Configuration</a>. </td><td><code>touchgfx_path</code>  </td><td><code>TouchGFXReleasePath</code>   </td></tr>
<tr>
<td><em><b>Opaque Image Format</b></em> </td><td>This property determines the format of solid images. See <a class="el" href="page_application_development.html#sect_application_development_project_conf_image_output_format">Image Output Format</a>. </td><td><code>opaque_image_format</code>  </td><td><code>OpaqueImageOutputFormat</code>   </td></tr>
<tr>
<td><em><b>Non-opaque Image Format</b></em> </td><td>This property determines the format of non-solid images. See <a class="el" href="page_application_development.html#sect_application_development_project_conf_image_output_format">Image Output Format</a>. </td><td><code>non_opaque_image_format</code>  </td><td><code>NonOpaqueImageOutputFormat</code>   </td></tr>
<tr>
<td><em><b>Alpha Dither</b></em> </td><td>This property determines whether the alpha channel of bitmaps should be dithered. See <a class="el" href="page_application_development.html#sect_application_development_project_conf_alpha_dither">Alpha Dithering</a>. </td><td><code>alpha_dither</code>  </td><td><code>AlphaDitherImage</code>   </td></tr>
<tr>
<td><em><b>Screen Orientation</b></em> </td><td>Let's you change the orientation of generated assets. See <a class="el" href="page_application_development.html#sect_application_development_project_conf_screen_orientation">Screen Orientation</a> </td><td><code>screen_orientation</code>  </td><td><code>RotateImage90</code>   </td></tr>
<tr>
<td><em><b>Text Data Format</b></em> </td><td>Let's you change the data format of generated text assets. See <a class="el" href="page_application_development.html#sect_application_development_project_conf_text_format">Text Format</a>. </td><td><code>text_data_format</code>  </td><td><code>TextDataFormat</code>   </td></tr>
<tr>
<td><em><b>Additional C/C++ compiler flags</b></em> </td><td>For users who want to supply additional compiler flags such as optimizations and symbols. </td><td><code>user_cflags</code>  </td><td><em>not supported</em>  </td></tr>
</table>
<p><br />
The following listings show a very common application configuration for each of the supported compilers with standard orientation of images, images without alpha-channel and standard text data format.</p>
<h2><a class="anchor" id="sect_application_development_project_conf_gcc"></a>
GCC</h2>
<p>Application specific GCC configurations from the folder are located at the root of each application in the folder <code>config/gcc</code>. These configurations are automatically imported by the Makefile for that same application.</p>
<pre class="fragment"># Relative location of the TouchGFX framework from root of application
touchgfx_path := ../../../touchgfx

# Optional additional compiler flags
user_cflags :=

# Settings for image converter output format
alpha_dither := yes
opaque_image_format := RGB565
non_opaque_image_format := RGB565 

# Settings for image converter screen orientation (empty string = default value, -rotate90 rotates the image 90 degrees)
screen_orientation :=

#Settings for Hardware accelerated text rendering on ST32F4 devices. Must correspond to value of bitsPerPixel for font to have any effect.
#If A4 blitcap is enabled for target specific HAL the fontconverter must generate compliant data format, otherwise resulting in a DMA Controller Configuration Error.
text_data_format :=
</pre><h2><a class="anchor" id="sect_application_development_project_conf_msvs"></a>
Microsoft Visual Studio 2010/2012</h2>
<p>All MSVS configurations in TouchGFX import the following application specific configuration from the <code>config/msvs</code> located at the root of the application: <code>config/msvs/Application.props</code>. These properties can also be edited using the MSVS IDE through the menu</p>
<pre class="fragment">Property Manager &gt; project_name &gt; Debug|Win32 &gt; project_name icon &gt; Common Properties &gt; User Macros
</pre><p><br />
A Property group called <code>UserMacros</code> is defined in the <code></code>.props file used by the Visual Studio project for the application, mirroring the settings from the <code>GCC</code> configuration above.</p>
<pre class="fragment">  &lt;PropertyGroup Label="UserMacros"&gt;
    &lt;RotateImage90&gt;false&lt;/RotateImage90&gt;
    &lt;TouchGFXReleasePath&gt;$(ProjectDir)\..\..\..\touchgfx&lt;/TouchGFXReleasePath&gt;
    &lt;AlphaDitherImage&gt;yes&lt;/AlphaDitherImage&gt;
    &lt;OpaqueImageOutputFormat&gt;RGB565&lt;/OpaqueImageOutputFormat&gt;
    &lt;NonOpaqueImageOutputFormat&gt;RGB565&lt;/NonOpaqueImageOutputFormat&gt;
    &lt;TextDataFormat&gt;&lt;/TextDataFormat&gt;
  &lt;/PropertyGroup&gt;
</pre><h2><a class="anchor" id="sect_application_development_project_conf_screen_orientation"></a>
Screen Orientation</h2>
<p>Screen orientation must be configured if the user interface orientation (portrait or landscape) is different from the native orientation of the TFT display itself. A TFT display is said to be native portrait if its width is smaller than its height. Please refer to <a class="el" href="page_advanced.html#sect_adv_display_orientation">Switching Display Orientation</a> for details on how to correctly set this property.</p>
<h2><a class="anchor" id="sect_application_development_project_conf_image_output_format"></a>
Image Output Format</h2>
<p>The image converter takes application image assets and convert them into a specific format based on two application configuration settings set by the user <em>opaque</em> <em>image</em> <em>format</em> and <em>non-</em> opaque <em>image</em> <em>format</em>. Depending on the target platform, the value of these properties can help optimize performance drastically.</p>
<p>The supported image formats are:</p><ul>
<li><code>RGB565</code> </li>
<li><code>ARGB8888</code> </li>
<li><code>BW</code> </li>
<li><code>BW_RLE</code> </li>
</ul>
<p>The default output format for solid images is <code>RGB565</code> and the default for images containing transparency is <code>RGB565</code> plus an alpha channel array. This format is optimized to give the best performance for most hardware setups. The <code>ARGB8888</code> format is supported by any platform in TouchGFX using the STMicroelectronics ST-STM32F429/439 microcontroller, enabling the ChromArt accelerator. Referring to <a class="el" href="page_application_development.html#sect_application_development_config">Application configuration</a>, we would configure gcc and msvs builds, respectively, to generate images in the RGB565 format by supplying the following value <code>RGB565</code> to both solid images (opaque) and transparent images (non-opaque).</p>
<p><br />
The BW and BW_RLE settings are for monochrome displays only. See <a class="el" href="page_advanced.html#sect_adv_monochrome">Configuring TouchGFX for 1BPP Monochrome</a> for details.</p>
<p><em>Note</em> that if you do not have any good reason to choose a different output format you should always use the default RGB565 setting.</p>
<p>GCC: </p><div class="fragment"><div class="line"><span class="preprocessor"># Settings for image converter output format</span></div>
<div class="line">opaque_image_format := RGB565  </div>
<div class="line">non_opaque_image_format := RGB565</div>
</div><!-- fragment --><p> <br />
</p>
<p>MSVS: </p><div class="fragment"><div class="line">&lt;OpaqueImageOutputFormat&gt;RGB565&lt;/OpaqueImageOutputFormat&gt;</div>
<div class="line">&lt;NonOpaqueImageOutputFormat&gt;RGB565&lt;/NonOpaqueImageOutputFormat&gt;</div>
</div><!-- fragment --><p> <br />
MSVS property configuration can by selecting the Property Manager and right-clicking the <em>project-name/Debug|Win32/project-name</em> icon to bring up the property pages for the project. Select "Common Properties/User Macros". A similar setting is available for the release build.</p>
<h2><a class="anchor" id="sect_application_development_project_conf_alpha_dither"></a>
Alpha Dithering</h2>
<p>Since the color channels are only 5/6 bits, having an 8-bit alpha channel will cause many blend operations to yield the same resulting color, thereby causing banding if the alpha channel is a gradient. With alpha dithering enabled, the alpha channel of each bitmap will be dithered from 8 to 5 bits. It is recommended to enable this setting as it will make gradients in the alpha channel appear smoother.</p>
<h2><a class="anchor" id="sect_application_development_project_conf_text_format"></a>
Text Format</h2>
<p>The <em>text format</em> property of the application configuration can be set to enable hardware rendering of 4bpp <em>(bits per pixel)</em> or 8bpp text if your target is a <a href="http://www.st.com/web/en/catalog/mmc/FM141/SC1169/SS1577?ecmp=stm32f429-439_enews_ss1577_jan2014&amp;sp_rid=Njk1NzY1ODc5MzUS1&amp;sp_mid=8196558">Chrom-ART accelerated ST platform</a>. By default, any such platform supported by TouchGFX is already <em>capable</em> of rendering in either of these formats but it is up to the <em>user</em> configuring the project to enable this feature by setting the appropriate value for the property relating to <em>text data format</em> in the application configuration.</p>
<p>Both the ST platforms supported by TouchGFX have ChromeArt capabilities (STM32F4 series) that support hardware rendering of texts if fonts are generated in the following two data formats:</p>
<ol type="1">
<li>A4 - Requires additional application configuration to alter the format output by the font converter</li>
<li>A8 - Requires <em>no</em> additional application configuration</li>
</ol>
<p>The following configurations would yield hardware accelerated rendering of 4bpp TTF fonts on STM32F4 based platforms. For this configuration to have any effect, the text typograph sheet in <em>assets/texts/texts.xlsx</em> should specify 4bpp for the desired font as specified in the table below, mimicking a row from the typography sheet. Likewise for 8bpp, except that no value for <em>text data format</em> in the application configurationis required.</p>
<table class="doxtable">
<tr>
<th>Typograhy name </th><th>Font </th><th>Size </th><th>Bpp  </th></tr>
<tr>
<td>Headline </td><td>RobotoCondensed-Reguar.ttf </td><td>40 </td><td>4  </td></tr>
</table>
<p><br />
GCC: </p><pre class="fragment">#Setting for Hardware accelerated text rendering on ST32F4 devices. Possible values: A4 or no value
text_data_format := A4 
</pre><p> <br />
MSVS: <br />
</p><pre class="fragment">  &lt;TextDataFormat&gt;A4&lt;/TextDataFormat&gt;
</pre><dl class="section note"><dt>Note</dt><dd>Any attempts, by the DMA controller, to make transfers in 4bpp mode using font data non-compliant with the A4 format will result in a DMA Controller Configuration Error.</dd></dl>
<h1><a class="anchor" id="sect_application_development_assets_and_tools"></a>
Assets and Tools</h1>
<p>A TouchGFX application includes a set of asset files as described in <a class="el" href="page_application_development.html#sect_application_development_assets">Application assets</a>. These assets are converted at compile time to internal C++ formats by various external converter tool. The converter tools are each described below. The converted files are all placed in the <code>generated/</code> folder.</p>
<h2><a class="anchor" id="sect_application_development_assets_and_tools_fonts"></a>
Font Converter</h2>
<p>The TouchGFX Font Converter accepts TrueType (<code></code>.ttf), OpenType (<code></code>.otf) fonts and Glyph Bitmap Distribution Format (<code></code>.bdf). Simply place the font in the <code>assets/fonts/</code> folder and the font will be available for reference in the text database (see <a class="el" href="page_application_development.html#sect_application_development_text_database">Text Database</a>).</p>
<p>Please note that a TouchGFX license does not in any way provide licenses for commercial use of any TrueType or OpenType fonts.</p>
<h3><a class="anchor" id="sect_application_development_texts_kerning"></a>
Kerning support</h3>
<p>Kerning is the process of adjusting the spacing between characters in a proportional font, usually to achieve a visually pleasing result. The TouchGFX font converter supports kerning by using the kerning information in the supplied font.</p>
<h2><a class="anchor" id="sect_application_development_assets_and_tools_images"></a>
Image Converter</h2>
<p>The following image formats are supported.</p><ul>
<li>24-bit bmp images (alpha channel not supported)</li>
<li>PNG images (24-bit RGB or 32-bit RGBA colors)</li>
</ul>
<p>The .png and .bmp images located in the assets/images folder or subfolders hereof are converted and placed in the generated/images folder. The conversion does Floyd-Steinberg dithering in order to reduce color banding in the generated 16 bit bitmaps.</p>
<p>The image conversion process supports opaque, transparent and semitransparent pixels when converting PNG images. Beware to use only what is necessary since the format has a huge impact on the overall performance and memory usage.</p><ul>
<li>Images containing only opaque pixels take up the smallest amount of memory and can in almost all cases be drawn efficiently by the hardware.</li>
<li>Images containing only opaque or fully transparent pixels take up the same amount of memory as the opaque case, but must in most cases be drawn by software. And thus is more demanding on the MCU.</li>
<li>Images containing semitransparent pixels take up more memory and will in almost all cases have to be drawn by software. It is uncommon in hardware to support per pixel alpha transparency, thus the software has to do a lot of work to read, blend and write pixels. Therefore it is advisable to limit the use of per pixel alpha transparency due to performance issues.</li>
</ul>
<p>To know more on how to use the generated images in the application read the section <a class="el" href="page_application_development.html#sect_application_development_using_images">Using Images</a>.</p>
<p>In the section <a class="el" href="page_application_development.html#sect_application_development_project_conf_image_output_format">Image Output Format</a> you can read more on how to configure the output format of the Image Converter.</p>
<p>To change the placement of bitmap data (internal vs. external flash), see <a class="el" href="page_advanced.html#sect_adv_bitmap_location">Changing the Location of Bitmap Data</a></p>
<h2><a class="anchor" id="sect_application_development_assets_and_tools_texts"></a>
Text Converter</h2>
<p>The Text Converter is an external tool that converts the information in the text spreadsheet (see below) to an internal C++ format used both by the simulator and on target. The tool is an integrated part of the build tool-chain and will be executed automatically when building the simulator. The Text Converter issues an error if the text spreadsheet violates any of the syntax rules. The Text Converter is not executed if the text spreadsheet has not been updated since last build. Beware that no warnings will be issued in this case. Either change or touch the text.xlsx file or rebuild if you need the Text Converter to be re-executed.</p>
<h3><a class="anchor" id="sect_application_development_text_database"></a>
Text Database</h3>
<p>The handling of text strings and translations in TouchGFX application are done in the <code>assets/texts/texts.xlsx</code> Excel spreadsheet. Please note that other programs than Excel can be used for editing the spreadsheet such as OpenOffice and LibreOffice.</p>
<p>This spreadsheet consists of two sheets. One defining the typographies used in the application and one defining the text strings and translations that are used.</p>
<p><b>The</b> <b>Typography</b> <b>Sheet</b> </p>
<p>The typography sheet lets you define all typographies that should be used in the application. A typography describes a specific text layout and consists of four values.</p>
<ul>
<li><b>Typography</b> <b>Name:</b> The name which you should reference the typography by in the Translation sheet</li>
<li><b>Font:</b> The name of the font to use for the given typography. This should match the name of a font located in the <code>assets/fonts/</code> directory. It must include the complete file name including extension. Example: miso-regular.ttf</li>
<li><b>Size:</b> The font size of the typography.</li>
<li><b>Bpp:</b> Bits per pixel. The number of bits that are used per pixel to represent the font. Legal values are <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>.</li>
</ul>
<p><em>Note:</em> If the Font is a Glyph Bitmap Distribution Format font (.bdf), not all font sizes can be rendered with the font. If the given size in the typography sheet does not match with the given font, the font convert utility will write a report with the supported font sizes, e.g. "Number of fixed sizes: 1 (15)" signifying that there is only one supported font size in the font, and that size is 15. Updating the size in the sheet to one of the supported sizes will solve the problem.</p>
<p><b>The</b> <b>Translation</b> <b>Sheet</b> </p>
<p>The translation sheet lets you define all text strings used in the application. A row represents one text string to be used in the application and includes the typography, alignment, and translations to all supported languages.</p>
<p>One row consists of the following values:</p>
<ul>
<li><b>Text</b> <b>ID:</b> The id of the string. This is the id that should be used to reference the text string in the application code. This is done by including the <code>texts/TextKeysAndLanguages.hpp</code> file which defines all the strings and languages. Notice that all text ids are prepended with T_ and converted to uppercase in the C++ definition.</li>
<li><b>Typography</b> <b>Name:</b> Specifies which typography the text string should use as default. This must match a typography name from the Typography sheet.</li>
<li><b>Alignment:</b> Specifies the default horizontal alignment of the text string. Legal values are <code>LEFT</code>, <code>RIGHT</code>, and <code>CENTER</code>.</li>
<li><b>Direction:</b> Specifies the default text direction of the text string. Legal values are <code>LTR</code> (Left-to-Right) and <code>RTL</code> (Right-to-Left), the default being <code>LTR</code>. The direction column can be omitted if <code>LTR</code> should be the default direction for all rows. The <code>RTL</code> option is primarily used for Arabic, Hebrew or other languages written from right to left.</li>
<li><b>Language</b> <b>column:</b> A language column is a column for a specific translation of all text strings. You can define as many language column that you want, by adding new columns with language names. A language name must be uppercase and contain 1 to 3 letters. E.g. <code>GB</code>, <code>DK</code>, <code>USA</code>, <code>CH</code>.</li>
<li><b>Language</b> <b>specific</b> <b>typography:</b> It is possible to override the default typography used for a specific language. This is done by introducing a column with the format language-TYPOGRAPHY e.g. <code>GB-TYPOGRAPHY</code>. Legal values are typographies defined in the Typography sheet. This is particular useful if the language uses characters that are not included in the font of the default typography e.g. Chinese characters. If this value is left empty for a specific text string, the default typography is used.</li>
<li><b>Language</b> <b>specific</b> <b>alignment:</b> It is possible to override the default alignment used for a specific language. This is done by introducing a column with the format language-ALIGNMENT e.g. <code>GB-ALIGNMENT</code>. Legal values are <code>LEFT</code>, <code>RIGHT</code>, and <code>CENTER</code>. If this value is left empty for a specific text string, the default alignment is used.</li>
<li><b>Language</b> <b>specific</b> <b>text</b> <b>direction:</b> It is possible to override the default text direction used for a specific language. This is done by introducing a column with the format language-DIRECTION e.g. <code>GB-DIRECTION</code>. Legal values are <code>LTR</code> and <code>RTL</code>. If this value is left empty for a specific text string, the default direction is used.</li>
</ul>
<p>For examples of how to use the Text Database see <code>example/text_example</code> and <code>example/arabic_text_example</code>.</p>
<p><b>Character</b> <b>Memory</b> <b>Optimization</b> </p>
<p>TouchGFX is optimized for low memory consumption. By analysing the characters used for a specific typography the number of generated characters (in internal C++ format) are minimized to the characters that are actually used by the application.</p>
<p><b>Wildcards</b> </p>
<p>It is possible to use run time values as part of text strings. This is possible by use of wildcards in the text strings. These are specified in the given format <code>&lt;*&gt;</code>, where the * represents an optional helping text which will not be included in the resulting text string. It is possible to have up to two wildcards in one text string. All translations for a given text must contain the same number of wildcards. The wildcard values are inserted at run time in the application C++ code. Example of wildcard usage: <code>"The temperature is &lt;insert_temperature&gt;°"</code>. One detail to notice is that due to the character memory optimization the only characters that are generated for a specific typography is the one used in texts having this typography. So to make sure that all characters that are to be used for wildcard values are generated, it is suggested to make a dummy text row having all the characters that are needed by wildcards for a specific typography. Example of dummy text: <code>"-0123456789"</code>. The wildcard format <code>"&lt;*&gt;"</code> can be escaped by using backslash notation like this: <code>"\&lt;not a wildcard\&gt;"</code>. This will result in the literal text <code>"&lt;not a wildcard&gt;"</code> being used in the application. See the text_example application for a wildcard example.</p>
<h1><a class="anchor" id="sect_application_development_concepts"></a>
Concepts</h1>
<p>This section discusses some of the underlying concepts of TouchGFX, some which are important to application developers.</p>
<h2><a class="anchor" id="sect_application_development_mvp"></a>
Model-View-Presenter</h2>
<p>Model-View-Presenter (MVP) is a common way of dividing responsibilites in UI applications. It separates the concerns of setting up the graphical elements UI, reacting to changes and maintaining UI state permanently. In the general case, a diagram of an MVP architecture can be seen here: </p><div class="image">
<img src="mvp.png" alt="mvp.png"/>
<div class="caption">
Generic MVP architecture</div></div>
 TouchGFX comes with a minimal baked in (but optional) variant of MVP. The TouchGFX flavour of MVP has one model and multiple pairs of views and presenters, one pair for each screen in the application. Using the built-in MVP mechanism you get the added benefit of a <a class="el" href="page_application_development.html#sect_application_development_malloc">Memory Allocation</a> scheme which helps reduce internal memory use of your application.</p>
<h3><a class="anchor" id="sect_application_development_mvp_model"></a>
Model</h3>
<p>The model takes care of the overall UI application state. The model will communicate with the rest of the system (the backend) in order to obtain the state needed for the UI. In this sense the model acts as a gateway to the rest of the system.</p>
<p>When changes occur in the model the current active <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> is notified of the change. This is done via methods in the ModelListener interface in the application.</p>
<h3><a class="anchor" id="sect_application_development_mvp_view"></a>
View</h3>
<p>A <a class="el" href="classtouchgfx_1_1_view.html">View</a> is responsible for setting up the graphical elements of the UI. A <a class="el" href="classtouchgfx_1_1_view.html">View</a> intercepts user events (e.g. a <a class="el" href="classtouchgfx_1_1_click_event.html">ClickEvent</a>) and takes action, usually delegating to the <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a>. The <a class="el" href="classtouchgfx_1_1_view.html">View</a> knows about the corresponding <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> enabling the view to inform the presenter of changes.</p>
<h3><a class="anchor" id="sect_application_development_mvp_presenter"></a>
Presenter</h3>
<p>The <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> orchestrates the Model and the <a class="el" href="classtouchgfx_1_1_view.html">View</a>. The <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> handles logic related to the UI elements. The <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> is informed when changes occur in the Model and then takes action to synchronize the <a class="el" href="classtouchgfx_1_1_view.html">View</a> appropriately. The <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> is informed when changes occur in the <a class="el" href="classtouchgfx_1_1_view.html">View</a> and then takes action to synchronize the Model appropriately.</p>
<h3><a class="anchor" id="sect_application_development_mvp_frontendapplication"></a>
FrontendApplication</h3>
<p>An application has a FrontendApplication. See the examples in <a class="el" href="page_examples.html">Examples</a>. The FrontendApplication provides methods for transitioning between different concrete views, e.g gotoSomeScreen.</p>
<p>When the application needs to go to a screen the current <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a> instructs the FrontendApplication to change screens. In order to accomplish this switch of screens the FrontendApplication remembers the screen to go to. The actual switch will be postponed to the next tick. This is done to preserve the integrity of memory.</p>
<h3><a class="anchor" id="sect_application_development_mvp_switching"></a>
Switching Screens</h3>
<p>Switching between screens is handled by the FrontendApplication. A switch is done in two steps. The first step, as described in <a class="el" href="page_application_development.html#sect_application_development_mvp_frontendapplication">FrontendApplication</a>, remembers the screen to switch to. The second step actually performs the switch. The second step is performed on the next tick.</p>
<p>The actual switch is done using makeTransition located in MVPApplication.hpp. This switches to the requested view and presenter using a <a class="el" href="classtouchgfx_1_1_transition.html">Transition</a>.</p>
<p>First makeTransition cleans up the current view and presenter as well as the last performed transition. Then a new transition, view and presenter is created and initialized. These are then connected and made aware of the model. And the switch is complete.</p>
<h3><a class="anchor" id="sect_application_development_mvp_classdiagram"></a>
Class Diagram, TouchGFX MVP</h3>
<p>The following class diagram depicts how the MVP elements are related in TouchGFX applications: </p><div class="image">
<img src="mvp-touchgfx.png" alt="mvp-touchgfx.png"/>
<div class="caption">
TouchGFX MVP</div></div>
<h2><a class="anchor" id="sect_application_development_drawables"></a>
Drawables</h2>
<p>In TouchGFX, all built-in and custom widgets and containers must derive from the <a class="el" href="classtouchgfx_1_1_drawable.html">Drawable</a> class. This base class contains a pure virtual <a class="el" href="classtouchgfx_1_1_drawable_a512986da799db258ce88e47964e97ff4.html#a512986da799db258ce88e47964e97ff4">draw</a> function which must be implemented. It also provides a range of common functionality like setting the size and position of the drawable.</p>
<p>This chapter deals with understanding the usage, hierarchy and types of Drawables that comes with TouchGFX. The <a class="el" href="page_application_development.html#sect_application_development_customwidgets">Custom Widgets and Containers</a> chapter describes how to implement your own custom drawables. There are two distinct direct subclasses of Drawable, namely <a class="el" href="classtouchgfx_1_1_widget.html">Widget</a> and <a class="el" href="classtouchgfx_1_1_container.html">Container</a>, organised according to the composite design pattern: </p><div class="image">
<img src="drawables-composite.png" alt="drawables-composite.png"/>
<div class="caption">
The composite pattern of Drawable, Widget and Container</div></div>
<br />
What this basically means is that Widget and all its derivatives are <em>leaf</em> nodes, whereas you can <a class="el" href="classtouchgfx_1_1_container_afcad4ee6a1f963058f3d9bd41b975d6c.html#afcad4ee6a1f963058f3d9bd41b975d6c">add</a> other drawables to Container and anything deriving from Container. The collection of available drawables in TouchGFX (as well as the ones you create yourself) will therefore either derive from Widget or Container, depending on whether it is able to contain other drawables.</p>
<h3><a class="anchor" id="sect_application_development_drawables_add"></a>
Adding Drawables to a View</h3>
<p>A <a class="el" href="classtouchgfx_1_1_view.html">View</a> contains a single root <a class="el" href="classtouchgfx_1_1_container.html">Container</a> to which the drawables to be displayed can be added. This is done by calling the <a class="el" href="classtouchgfx_1_1_screen_afcad4ee6a1f963058f3d9bd41b975d6c.html#afcad4ee6a1f963058f3d9bd41b975d6c">add</a> function of the view. The order in which drawables are added determines their Z-order. To remove a previously added drawable, call <a class="el" href="classtouchgfx_1_1_screen_a0269f5d1a532a70da001934f8fe98c0b.html#a0269f5d1a532a70da001934f8fe98c0b">remove</a>.</p>
<p>Internally, each drawable contains a pointer to the next drawable (called nextSibling), thus forming a linked list. The Container subclass additionally provides a pointer to its first child to form a hierachical structure. The following diagram shows an example of a simple scene graph:</p>
<div class="image">
<img src="drawables-scene.png" alt="drawables-scene.png"/>
<div class="caption">
Scene graph composition through linked lists</div></div>
<br />
By using this approach each Drawable automatically provides the memory needed for the scene graph and it scales to any number of drawables. Although not displayed here, each Drawable also has a parent pointer so the root container can be reached from any drawable in the scene.</p>
<p>The Z-order of the drawables in the example is from highest (front) to lowest (back) is:</p><ol type="1">
<li>text2</li>
<li>keyboard</li>
<li>text1</li>
<li>button1</li>
<li>myContainer</li>
<li>bgImage</li>
<li>container</li>
</ol>
<h3><a class="anchor" id="sect_application_development_drawables_coordinates"></a>
Coordinate Systems</h3>
<p>Coordinates can be expressed in one of two ways. The first is <em>absolute</em> coordinates where the following is true:</p><ul>
<li>Upper left corner is (0, 0)</li>
<li>Upper right corner is (WIDTH-1, 0)</li>
<li>Lower left corner is (0, HEIGHT-1)</li>
<li>Lower right coner is (WIDTH-1, HEIGHT-1)</li>
</ul>
<p>The low-level classes such as <a class="el" href="classtouchgfx_1_1_l_c_d.html">LCD</a> operate solely on absolute coordinates, so in order to actually draw anything, coordinates must be converted to absolute.</p>
<p>Instead the entire drawable hierarchy uses <em>relative</em> coordinates throughout, which simply means coordinates relative to the parent drawable (ie. the offset from the position of the parent). The root container of a view is always positioned at (0, 0), so the drawables added to the root container will have coordinates that are the same in both relative and absolute. So, to place an <a class="el" href="classtouchgfx_1_1_image.html">Image</a> in (50, 50) absolute for example, it can either be given the position of (50, 50) and added to the root container, or it could be added to a different container located at, say, (30, 20) and given the coordinates (20, 30). The Drawable class provides a function that can translate its relative coordinates to absolute. This is done by traversing up the scene graph, adding the x and y values at each level until the root container is reached.</p>
<p><em>Note:</em> relative coordinates can be negative.</p>
<p>Relative coordinates were chosen because they generally makes life much easier when implementing a user interface. The conversion to absolute coordinates when drawing or when handling touch input events is done entirely by the TouchGFX framework and is completely transparent to the application developer.</p>
<h3><a class="anchor" id="sect_application_development_drawables_size"></a>
Size and Position</h3>
<p>All drawables have a position expressed as X and Y in relative coordinates as explained above. In addition, all drawables have a width and a height. For built-in widgets that operate on bitmaps like <a class="el" href="classtouchgfx_1_1_image.html">Image</a> and <a class="el" href="classtouchgfx_1_1_button.html">Button</a>, the width and height is automatically inferred from the size of the bitmap, so only the position needs to be set. The width and height dictates the visible area of a widget. Although it would not make much sense in most cases, an Image for instance can be set to a smaller width or height than the source bitmap, which would cause it to be clipped. <a class="el" href="classtouchgfx_1_1_container.html">Containers</a>, being drawables too, also have a width and a height which effectively act as a viewport. That is, if you add drawables to a container and position them outside the region expressed by the container's width and height, those child drawables will be clipped. Viewports can be a useful feature and are used in <a class="el" href="classtouchgfx_1_1_scrollable_container.html">ScrollableContainer</a> where the size of the scrollable container denotes the visible area and scrolling automatically being enabled when the child drawables are larger than that area.</p>
<h3><a class="anchor" id="sect_application_development_drawables_limitation"></a>
Limitations on the number of drawables</h3>
<p>Due to memory optimization reasons it is only possible to have 150 visible drawables on a screen at one time. Any exceeding drawables will not be shown.</p>
<h2><a class="anchor" id="sect_application_development_event"></a>
Events</h2>
<h3><a class="anchor" id="sect_application_development_event_input"></a>
Input Events</h3>
<p>TouchGFX supports three event types that originate from touch screen input, as well as a generic event type that can originate from other sources. These are described in the following.</p>
<p>A <a class="el" href="classtouchgfx_1_1_click_event.html">ClickEvent</a> is issued when the touch screen detects a change in whether or not it is being pressed. Depending on the screen coordinates where the event occured, it will automatically be routed to the correct <a class="el" href="classtouchgfx_1_1_drawable.html">Drawable</a> - that is, the drawable with the highest Z-order (the front-most drawable) that are both visible and touchable and are covering those coordinates. This notification will happen through a call to the <a class="el" href="classtouchgfx_1_1_drawable_a7d14fa46f4f72affe2023c2b3646b3d5.html#a7d14fa46f4f72affe2023c2b3646b3d5">Drawable::handleClickEvent</a> function, which takes a <a class="el" href="classtouchgfx_1_1_click_event.html">ClickEvent</a> object as parameter. By examining the parameter, the coordinates can be obtained. Upon the reception of the event, the coordinates have automatically been translated to the coordinate system of the drawable. That means, a click event in the top left corner of a drawable will report coordinates (0,0). The type of click event is also included in the ClickEvent object. There are three types:</p><ul>
<li>PRESSED which means that a new touch was detected at the specified coordinates.</li>
<li>RELEASED which means that a touch is no longer detected.</li>
<li>CANCEL which means that a touch has been dragged outside the border of the drawable.</li>
</ul>
<p>The default implementation of handleClickEvent does nothing. Custom widgets can override this, of course. Most commonly, drawables that need to respond to click events derive from <a class="el" href="classtouchgfx_1_1_abstract_button.html">AbstractButton</a>. A user-defined callback which will trigger if a "click" is detected (a PRESSED event followed by a RELEASED event with no intermittent CANCEL events received) can be assigned to such a subclass.</p>
<p>The rules for receiving click events are as follows:</p><ul>
<li>Only drawables that are <em>visible</em> (<a class="el" href="classtouchgfx_1_1_drawable_a71639c6634c5dcf6d1bb21b8b1b61f5b.html#a71639c6634c5dcf6d1bb21b8b1b61f5b">Drawable::setVisible</a>, default true) AND <em>touchable</em> (<a class="el" href="classtouchgfx_1_1_drawable_ae4c38eadb852b153850ea7ded1f50a19.html#ae4c38eadb852b153850ea7ded1f50a19">Drawable::setTouchable</a>, default false) are eligible for receiving touch events.</li>
<li>Click events are not propagated to children of a drawable with visible set to false.</li>
<li>Click events are propagated to children of a drawable with touchable set to false.</li>
<li>The PRESSED event will always be issued to the highest z-order (front-most) drawable which is covering the coordinate area and satisfies the rules above. No other drawables are notified.</li>
<li>The RELEASED event will always be issued to the exact same drawable that received the PRESSED event, regardless of whether the coordinates at the time of detecting the release are inside the area of that drawable. No other drawables are notified.</li>
<li>The CANCEL event is likewise only sent to the drawable that received the PRESSED notification.</li>
</ul>
<h3><a class="anchor" id="sect_application_development_events_drag"></a>
Drag Events</h3>
<p>A drag event will be reported if the user moves the finger/stylus on the touch screen. Drag events will therefore always occur between a ClickEvent::PRESSED event and ClickEvent::RELEASED event. Drag events are sampled at each tick, so there will most likely be a series of drag events reported when moving the finger. A <a class="el" href="classtouchgfx_1_1_drag_event.html">DragEvent</a> is issued to the appropriate drawable by calling the <a class="el" href="classtouchgfx_1_1_drawable_ae4e6dbc9c26df1a1f6bea4f6a0c1460e.html#ae4e6dbc9c26df1a1f6bea4f6a0c1460e">Drawable::handleDragEvent</a> function. In the object passed as parameter, the coordinates of where the drag began (labeled oldX/oldY) as well as where the drag ended (labeled newX/newY) can be obtained.</p>
<p>Receiving drag events follows the same rules as click events. One exception is that the receiving drawable is actually determined at the time of a ClickEvent::PRESSED, not each time a drag occurs.</p>
<p>All subsequent drag events until a ClickEvent::RELEASED is detected will be reported to the receiving drawable found at the time of the ClickEvent::PRESSED.</p>
<p>Drawables can easily be made draggable (following the movement of the drag event) by using the Draggable mixin.</p>
<h3><a class="anchor" id="sect_application_development_events_gestures"></a>
Gesture Events</h3>
<p>A gesture event is a more complicated event than a simple drag. Currently TouchGFX supports only one type of gesture, namely swipe.</p>
<p>A swipe in this context probably means what you think it means, but the actual definition in TouchGFX is that it is a drag immediately followed by releasing the touch. That is, the input mechanism is interpreted as being "in motion" when releasing, indicating that the user interface should perform some type of scrolling with a gradual deceleration. Like with drags, gesture events will happen in between ClickEvent::PRESSED and ClickEvent::RELEASED events.</p>
<p>A gesture is issued to the appropriate drawable by calling the function <a class="el" href="classtouchgfx_1_1_drawable_a1478bb30ace10ec7c9f55629cdd5f8ee.html#a1478bb30ace10ec7c9f55629cdd5f8ee">Drawable::handleGestureEvent</a>. The default implementation does nothing. The event object will contain the coordinates of the gesture, again in the coordinate system of the receiving drawable. Additionally the gesture event object contains a velocity which, for swipes, is an indication of the length of the underlying drag that caused the gesture to fire. A small velocity can be interpreted as a "flick", whereas a higher value should likely be interpreted as a normal swipe.</p>
<p>The <a class="el" href="classtouchgfx_1_1_scrollable_container.html">ScrollableContainer</a> will respond to gesture events by performing a scroll relative to the reported velocity.</p>
<p>Gesture events will always be sent to the drawable that received the ClickEvent::PRESSED event at the time the touch screen was initially pressed, regardless of whether the coordinates where the gesture was performed intersects with that drawable.</p>
<h3><a class="anchor" id="sect_application_development_events_other"></a>
Other Input Events</h3>
<p>Aside from the three touch-screen based events described above, there is a generic event type called a <em>KeyEvent</em> which can be used to signal other forms of input events in an application-specific manner. Possible sources for events of this type could be physical pushbuttons, an attached keyboard or something else entirely. TouchGFX in itself does not produce, nor process any events of this type. But the <a class="el" href="classtouchgfx_1_1_application.html">Application</a> class, from which your concrete FrontendApplication derives, has a function called <a class="el" href="classtouchgfx_1_1_application_abb0784547f5fe9efbd534dab9db14e7b.html#abb0784547f5fe9efbd534dab9db14e7b">handleKeyEvent</a>, which will delegate the event to the currently active <a class="el" href="classtouchgfx_1_1_view.html">View</a>. Thus, you can override this function and perform the appropriate actions, like displaying a dialog or notifying the presenter.</p>
<p><em>Note:</em> A pointer to the Application class can be obtained from anywhere through the <a class="el" href="classtouchgfx_1_1_application_a6e81e2cec56adf3dd681532078c77656.html#a6e81e2cec56adf3dd681532078c77656">getInstance</a> function, so any code can call the handleKeyEvent function.</p>
<h3><a class="anchor" id="sect_application_development_event_timers"></a>
Timers</h3>
<p>Timer ticks can be useful in the UI for creating animations or displaying something for a certain amount of time. The framework provides a timer tick that can be used for these purposes in two ways, described in the following.</p>
<p>All containers and widgets have a <a class="el" href="classtouchgfx_1_1_drawable_ad39a7a733e398154f1bddefbbcd0bb32.html#ad39a7a733e398154f1bddefbbcd0bb32">handleTickEvent</a> function, which is an empty virtual function of the <a class="el" href="classtouchgfx_1_1_drawable.html">Drawable</a> base class. This function can be overridden to perform the actions necessary at each tick. For performance reasons, this function is not normally called though, unless explicitly requested. By calling <a class="el" href="classtouchgfx_1_1_application_a5c54374756338ccf158b197f64470345.html#a5c54374756338ccf158b197f64470345">Application::registerTimerWidget</a> with a pointer to the specific <a class="el" href="classtouchgfx_1_1_drawable.html">Drawable</a>, that drawable will have its handleTickEvent function called at every tick from that point on. Unsurprisingly, calling <a class="el" href="classtouchgfx_1_1_application_a67a336123386c822f49194c77446e77b.html#a67a336123386c822f49194c77446e77b">Application::unregisterTimerWidget</a> will cause the drawable to no longer receive tick events. Up to 10 drawables can be registered at any one time.</p>
<p><em>Note:</em> When switching to another screen, the list of drawables that receive tick events is automatically cleared (since those drawables have effectively ceased to exist).</p>
<p>Alternatively, the timer tick could be handled in the active <a class="el" href="classtouchgfx_1_1_view.html">View</a>. This is useful if you want to perform actions across multiple drawables, or e.g. notify the <a class="el" href="classtouchgfx_1_1_presenter.html">Presenter</a>. Not unlike the case with drawables, all views also have a <a class="el" href="classtouchgfx_1_1_screen_ad39a7a733e398154f1bddefbbcd0bb32.html#ad39a7a733e398154f1bddefbbcd0bb32">handleTickEvent</a> function which in the base implementation does nothing. But since there is always only one view active, this function will be called automatically at each tick without the need to register for it.</p>
<h3><a class="anchor" id="sect_application_development_external_events"></a>
External Events</h3>
<p>It is frequently necessary to propagate other event types to the UI. This could be, for instance, a change in battery level, current time changed, ADC sample events or messages from other RTOS tasks in the system. Usually the recommended way of doing this is to make the Model (see <a class="el" href="page_application_development.html#sect_application_development_mvp">Model-View-Presenter</a>) check for the event. The default Model class distributed with the examples and template will already contain a tick() function, which is called automatically every tick. You can implement the Model::tick function such that the source of your events (hardware layer, OS mailbox, ..) is polled. If an event occurs that must be propagated to the UI, simply make use of the fact that the model always has a pointer to the currently active Presenter (through the ModelListener interface), on which it can call a function matching the event. It would then be up to the active presenter to decide whether or not that event should result in UI changes, or if the event can be disregarded. For instance, a "current time changed" event would only be of interest to presenters associated with screens that actually display the current time. Other presenters can leave that particular event function unimplemented.</p>
<h2><a class="anchor" id="sect_application_development_malloc"></a>
Memory Allocation</h2>
<p>In principle you can use any memory allocation scheme you wish in TouchGFX. For convenience we have included a default memory allocation scheme that operates on the <a class="el" href="page_application_development.html#sect_application_development_mvp">Model-View-Presenter</a> architecture. It is somewhat complex internally, but very effective and should be relatively easy to use. The allocation scheme uses static memory allocation only - that means you will know at compile-time exactly how much RAM your user interface is going to require.</p>
<p>Recall from the MVP section that the user interface consists of a Model and a number of Presenter-View pairs. The Model is always accessible, so the appropriate amount of memory (sizeof(Model)) is reserved. But only one Presenter-View pair is active at a time. By use of C++ templates, the size of the biggest presenter and the biggest view is determined at compile time, and memory for the largest presenter and the largest view is reserved. When switching to a new screen (presenter-view pair), the new presenter and view are then simply placement new'ed into these two memory blocks. The drawables for any given view are placed as members of that view, so the memory needed for them will be included in the memory reserved for the view. Aside from presenters and views, <a class="el" href="classtouchgfx_1_1_transition.html">Transitions</a> are also allocated in this manner.</p>
<p>The FrontendHeap is the application-specific class that defines the memory blocks needed for the UI. Since it needs to calculate the sizes of the biggest presenter, the biggest view and the biggest transition, it contains a list of the used types for each of these that needs to be maintained. That is, if you add a new presenter and a new view, you need to update the lists accordingly. If you want to understand the gritty details of how the largest type is calculated, have a look at Meta.hpp, but you will also get by fine by simply copy-pasting when inserting new entries into the lists. The following snippet is taken from the FrontendHeap class in <a class="el" href="page_examples.html#sect_custom_transition_example">Custom Transition Example</a> which contains five presenter-view pairs and, incidentally, also five transitions. </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * A list of all view types. Must end with meta::Nil.</span></div>
<div class="line"><span class="comment"> * @note All view types used in the application MUST be added to this list!</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> meta::TypeList&lt; MainView,</div>
<div class="line">                        meta::TypeList&lt; LeftView,</div>
<div class="line">                        meta::TypeList&lt; RightView,</div>
<div class="line">                        meta::TypeList&lt; DownView,</div>
<div class="line">                        meta::TypeList&lt; UpView,</div>
<div class="line">                        meta::Nil &gt; &gt; &gt; &gt;</div>
<div class="line">                      &gt; ViewTypes;</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * A list of all presenter types. Must end with meta::Nil.</span></div>
<div class="line"><span class="comment"> * @note All presenter types used in the application MUST be added to this list!</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> meta::TypeList&lt; MainPresenter,</div>
<div class="line">                        meta::TypeList&lt; LeftPresenter,</div>
<div class="line">                        meta::TypeList&lt; RightPresenter,</div>
<div class="line">                        meta::TypeList&lt; DownPresenter,</div>
<div class="line">                        meta::TypeList&lt; UpPresenter,</div>
<div class="line">                        meta::Nil &gt; &gt; &gt; &gt;</div>
<div class="line">                      &gt; PresenterTypes;</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * A list of all transition types. Must end with meta::Nil.</span></div>
<div class="line"><span class="comment"> * @note All transition types used in the application MUST be added to this list!</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> meta::TypeList&lt; NoTransition,</div>
<div class="line">                        meta::TypeList&lt; SlideTransition&lt;Transition::LEFT&gt;,</div>
<div class="line">                        meta::TypeList&lt; SlideTransition&lt;Transition::RIGHT&gt;,</div>
<div class="line">                        meta::TypeList&lt; SlideTransition&lt;Transition::DOWN&gt;,</div>
<div class="line">                        meta::TypeList&lt; SlideTransition&lt;Transition::UP&gt;,</div>
<div class="line">                        meta::Nil &gt; &gt; &gt; &gt;</div>
<div class="line">                        &gt; TransitionTypes;</div>
</div><!-- fragment --><p>Maintaining the list above is all you need to worry about in terms of memory allocation. But (as stated in the comments) it is <b>important</b> to keep these lists updated, otherwise horrible crashes will ensue.</p>
<p>Purely for reference, it can be mentioned that the member variables of FrontendHeap represents what is actually allocated: </p><div class="fragment"><div class="line">Partition&lt; PresenterTypes, 1 &gt; presenters;</div>
<div class="line">Partition&lt; ViewTypes, 1 &gt; views;</div>
<div class="line">Partition&lt; TransitionTypes, 1 &gt; transitions;</div>
<div class="line">FrontendApplication app;</div>
<div class="line">Model model;</div>
</div><!-- fragment --><p> That is, three memory blocks for the presenters, views and transitions plus the actual FrontendApplication and Model objects. So by doing a sizeof(FrontendHeap) you will know how much memory your user interface requires.</p>
<h2><a class="anchor" id="sect_application_development_customwidgets"></a>
Custom Widgets and Containers</h2>
<p>TouchGFX provides built-in widgets and containers, such as <a class="el" href="classtouchgfx_1_1_button.html">Button</a>, <a class="el" href="classtouchgfx_1_1_image.html">Image</a> and <a class="el" href="classtouchgfx_1_1_container.html">Container</a>, which can be used off-the-shelf to create a GUI (see <a class="el" href="page_application_development.html#sect_application_development_elements">Widgets, Containers, Mixins, Canvas Widgets</a> for the complete list). However, an application might require some functionality or appearance that is not provided by the built-in widgets and containers. In this case, custom widgets and containers can be implemented and used to get the desired look and feel.</p>
<h3><a class="anchor" id="sect_application_development_customwidgets_tweak_existing"></a>
Tweaking Existing Widgets</h3>
<p>One way of creating custom widgets in TouchGFX, is by changing the functionality of the built-in widgets. This is relatively straightforward since it is done by the using C++ inheritance to inherit from one of the built-in widgets. Thus one can take advantage of the possibilities offered by inheritance, such as accessing public and protected members and functions and overriding virtual functions. Almost all functions are virtual and members are protected, so the framework can be modified to a very large degree by overriding.</p>
<p>An example of such a custom widget can be seen in the <a class="el" href="page_examples.html#sect_custom_widget_example">Custom Widget Example</a> where a custom button is implemented and used.</p>
<p>The code snippet below shows the header file for the custom widget <em>FadeButton</em> which is implemented in the <a class="el" href="page_examples.html#sect_custom_widget_example">Custom Widget Example</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef FADEBUTTON</span></div>
<div class="line"><span class="preprocessor">#define FADEBUTTON</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/widgets/Button.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>FadeButton : <span class="keyword">public</span> <a class="code" href="classtouchgfx_1_1_button.html">Button</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FadeButton(<span class="keywordtype">bool</span> initiallyVisible);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> fadeOut();</div>
<div class="line">    <span class="keywordtype">void</span> fadeIn();</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handleTickEvent();</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> fadingOut;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // FADEBUTTON</span></div>
</div><!-- fragment --><p>Notice how the <em>FadeButton</em> inherits from the <a class="el" href="classtouchgfx_1_1_button.html">Button</a> class to get the built-in functionality of the the <a class="el" href="classtouchgfx_1_1_button.html">Button</a>. This means that the <em>FadeButton</em> gets the behavior that can be expected by a button, such as click callbacks, the possibility to set the positions of the button etc.</p>
<p>The <em>FadeButton</em> then adds custom behaviour by adding the <em>fadeOut()</em> and <em>fadeIn()</em> functions and by overriding the inherited <a class="el" href="classtouchgfx_1_1_drawable_ad39a7a733e398154f1bddefbbcd0bb32.html#ad39a7a733e398154f1bddefbbcd0bb32">handleTickEvent()</a> function. The implementation of <em>fadeOut()</em> and <em>fadeIn()</em> can be seen in the following code snippet, that shows how they call <a class="el" href="classtouchgfx_1_1_application_a5c54374756338ccf158b197f64470345.html#a5c54374756338ccf158b197f64470345">registerTimerWidget(Drawable* w)</a> to make the framework call the <a class="el" href="classtouchgfx_1_1_drawable_ad39a7a733e398154f1bddefbbcd0bb32.html#ad39a7a733e398154f1bddefbbcd0bb32">handleTickEvent()</a> function for every tick.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FadeButton::fadeOut()</div>
<div class="line">{</div>
<div class="line">    fadingOut = <span class="keyword">true</span>;</div>
<div class="line">    Application::getInstance()-&gt;registerTimerWidget(<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Deactivate during fade out</span></div>
<div class="line">    setActive(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> FadeButton::fadeIn()</div>
<div class="line">{</div>
<div class="line">    fadingOut = <span class="keyword">false</span>;</div>
<div class="line">    Application::getInstance()-&gt;registerTimerWidget(<span class="keyword">this</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the code snippet below it can be seen how the <em>handleTickEvent()</em> implementation alters the value of the inherited <a class="el" href="classtouchgfx_1_1_button.html#acf5bb76caa419c0fa231dbd66c881084">alpha</a> member to obtain a fading effect.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FadeButton::handleTickEvent()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(fadingOut)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(alpha &lt;= 2) <span class="comment">// Be careful of not underrunning datatype</span></div>
<div class="line">        {</div>
<div class="line">            alpha = 0;</div>
<div class="line">            Application::getInstance()-&gt;unregisterTimerWidget(<span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            alpha -= 3;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// fading in</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(alpha &gt;= 253) <span class="comment">// Be careful of not overrunning datatype</span></div>
<div class="line">        {</div>
<div class="line">            alpha = 255;</div>
<div class="line">            Application::getInstance()-&gt;unregisterTimerWidget(<span class="keyword">this</span>);</div>
<div class="line">            <span class="comment">// Activate after fade in is finished</span></div>
<div class="line">            setActive(<span class="keyword">true</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            alpha += 3;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Force redrawing of FadeButton, since changing alpha does not yield redraw.</span></div>
<div class="line">    invalidate();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="sect_application_development_customwidgets_container"></a>
Custom Container</h3>
<p>Custom containers can be used to implement a custom widget by letting the custom container contain and aggregate other widgets. The custom container can then implement functions that forward calls to the widgets it contains. Imagine that we need a widget which is a normal button that also displays a text below the button image. This is a simple case of aggregating already existing functionality (as provided by <a class="el" href="classtouchgfx_1_1_button.html">Button</a> and <a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a>), so we can simply create a container with those two widgets as members:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/Button.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/TextArea.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/Container.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MyButtonWithLabel : <span class="keyword">public</span> Container</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyButtonWithLabel()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// The constructor simply adds the two widgets as children of this inherited Container</span></div>
<div class="line">    add(btn);</div>
<div class="line">    add(txt);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> setBitmaps(<span class="keyword">const</span> Bitmap&amp; bmpReleased, <span class="keyword">const</span> Bitmap&amp; bmpPressed)</div>
<div class="line">  {</div>
<div class="line">    btn.setBitmaps(bmpReleased, bmpPressed);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// set the Y-coordinate of the textarea so it appears 2 pixels below the button image.</span></div>
<div class="line">    txt.setY(bmpReleased.getHeight() + 2);</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">void</span> setLabelText(TypedText t)</div>
<div class="line">  {</div>
<div class="line">    txt.setTypedText(t);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> setAction(SignalBase1&lt; const AbstractButton&amp; &gt;&amp; signal) { btn.setAction(signal); }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Button btn;</div>
<div class="line">  TextArea txt;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Notice how <em>MyButtonWithLabel</em> inherits from <a class="el" href="classtouchgfx_1_1_container.html">Container</a> and how it uses the inherited <a class="el" href="classtouchgfx_1_1_container_afcad4ee6a1f963058f3d9bd41b975d6c.html#afcad4ee6a1f963058f3d9bd41b975d6c">add(Drawable&amp; d)</a> function to add the widgets.</p>
<h3><a class="anchor" id="sect_application_development_customwidgets_widget"></a>
Custom Widget</h3>
<p>If the desired look and feel or functionality cannot be achieved by one of the previously described functions, one can implement a custom widget by inheriting from the abstract <a class="el" href="classtouchgfx_1_1_widget.html">Widget</a> base class. Creating a custom widget by inheriting from <a class="el" href="classtouchgfx_1_1_widget.html">Widget</a>, provides the least amount of off-the-shelf functionality while it provides the most freedom when implementing custom widgets.</p>
<p>It enables one to control exactly how the the framework draws the custom widget and thereby how it looks. The implementation of how the custom widget is drawn can also affect how well drawing the widget performs, and thus the performance of the framework. Furthermore, inheriting from <a class="el" href="classtouchgfx_1_1_widget.html">Widget</a> enables the custom widget to save RAM by leaving out members that might otherwise be unnecessarily inherited by using one of the other approaches for creating custom widgets.</p>
<p>When implementing a custom widget by inheriting from the <a class="el" href="classtouchgfx_1_1_widget.html">Widget</a>, it is necessary to at least implement <a class="el" href="classtouchgfx_1_1_drawable_a512986da799db258ce88e47964e97ff4.html#a512986da799db258ce88e47964e97ff4">draw</a> and <a class="el" href="classtouchgfx_1_1_drawable_a42d2a8956f78afa91d20f0a3fcf66d1c.html#a42d2a8956f78afa91d20f0a3fcf66d1c">getSolidRect</a> since these are pure virtual functions in the <a class="el" href="classtouchgfx_1_1_drawable.html">Drawable</a> class. This is in contrast with deriving from <a class="el" href="classtouchgfx_1_1_container.html">Container</a> where you need not worry about these functions as they will simply delegate the requests to the contained drawables, which will ultimately be leafs (widgets). The two functions are explained in detail in the following.</p>
<p><b>getSolidRect</b> </p>
<p>The getSolidRect function exists as part of the rendering algorithm of TouchGFX in order to do effective occlusion culling where anything hidden in the background is skipped when drawing. In essence it is a contract in which the widget guarantees that the area returned by getSolidRect is a completely solid rectangle (no transparent pixels, no alpha-blending). That is, it informs the framework that it is not necessary to draw anything in the background in this area, since it will be overshadowed by this particular widget anyway. The implementation of such a function is completely indifferent to the particular Z-ordering and what other widgets might be on the screen. It simply answers the question <em>"If I call draw on you, what is the largest rectangular area that you are going to cover such that any background widget will not be visible?"</em>. It is merely an optimization &ndash; all widgets could return an empty <a class="el" href="classtouchgfx_1_1_rect.html">Rect</a> and the user interface would still look the same. The performance would be much worse though, since a user interface typically consists of several layers of widgets and without this optimization the framework would be forced to draw all the layers, including pixels that are not visible because something else covers it.</p>
<p>Widgets that display bitmaps can use the information automatically generated by the imageconverter for their getSolidRect implementation. For example, this is the implementation of getSolidRect from the <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget: </p><div class="fragment"><div class="line">Rect Image::getSolidRect()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">if</span> (alpha &lt; 255) </div>
<div class="line">    <span class="keywordflow">return</span> Rect(0,0,0,0); <span class="comment">//If we are alpha-blending, we are not solid.</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> bitmap.getSolidRect();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For widgets that are not based on bitmaps but instead draw lines or individual pixels, getSolidRect can just return an empty area. This is typically not a problem because the amount of pixels drawn in this manner is likely to be low. For example, a <a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a> draws only a fraction of the pixels actually covered by the width and height of the widget. So it returns simply an empty area, meaning the entire area covered by this widget will also be drawn by the background widget, and the pixels representing the actual text will therefore be drawn twice.</p>
<p><b>draw</b> </p>
<p>The <a class="el" href="classtouchgfx_1_1_drawable_a512986da799db258ce88e47964e97ff4.html#a512986da799db258ce88e47964e97ff4">draw(const Rect&amp; invalidatedArea) const</a> function is what actually makes something appear on the screen by manipulating the pixels in the frame buffer. This is typicall done through the <a class="el" href="classtouchgfx_1_1_l_c_d.html">LCD</a> interface, which contains functions for drawing bitmaps, texts, rectangles and lines. It is also possible, through the <a class="el" href="classtouchgfx_1_1_h_a_l_a3b3cc3d8580539ffb5cf554569917157.html#a3b3cc3d8580539ffb5cf554569917157">lockFrameBuffer</a> function in <a class="el" href="classtouchgfx_1_1_h_a_l.html">HAL</a>, to obtain a pointer directly to the actual frame buffer itself, allowing direct manipulation of pixels. There are two important things to note regarding the draw function. It is <em>const</em>, which means that it can not modify member variables. This is by design because the framework might choose to call draw on a widget in several partial steps (or not at all). Therefore any assumptions about when and how the draw function is called are likely to be false, so updating state information inside this function would often lead to unexpected results.</p>
<p>The second thing to consider is the argument <em>invalidatedArea</em> passed to the draw function. This is a rectangle describing the subregion of the widget to draw. If the entire widget is to be drawn, the invalidatedArea will be (0, 0, width of widget, height of widget). The implementation of draw <em>must</em> respect the invalidatedArea by only drawing inside that area. If a draw function draws outside that area it will result in visible errors in Z-order on the display, even if the pixels being drawn are still inside the area of the widget. As an example, here is the draw function of <a class="el" href="classtouchgfx_1_1_image.html">Image</a>: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Image::draw(<span class="keyword">const</span> Rect&amp; invalidatedArea)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    Rect meAbs;</div>
<div class="line">    translateRectToAbsolute(meAbs);</div>
<div class="line">    Rect dirtyBitmapArea = bitmap.getRect() &amp; invalidatedArea; <span class="comment">// operator&amp; overloaded to mean intersection of two areas</span></div>
<div class="line">    LCD::drawPartialBitmap(bitmap, meAbs.x, meAbs.y, dirtyBitmapArea, alpha);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Notice that a dirtyBitmapArea is calculated as the intersection of the bitmap area with the invalidated area, and only that result is being passed to <a class="el" href="classtouchgfx_1_1_l_c_d_a21fc0988883bc392096c8eb21b0710b7.html#a21fc0988883bc392096c8eb21b0710b7">drawPartialBitmap</a>.</p>
<h2><a class="anchor" id="sect_application_development_canvas_widgets"></a>
Canvas Widgets</h2>
<p>Canvas Widgets and the <a class="el" href="classtouchgfx_1_1_canvas_widget_renderer.html">Canvas Widget Renderer</a> are a powerful and versatile add-on to TouchGFX which provides nice smooth, anti-aliased drawing of geometric shapes using relatively little memory while maintaining high performance. However, rendering geometrical shapes must be seen as a quite expensive operation and can easily strain the microcontrollers resources if not used carefully.</p>
<p>The Canvas Widget Renderer (hereafter referred to as CWR) is a general graphics engine providing optimized drawing primitives, automatically eliminating most superfluous drawings. CWR is used by TouchGFX for drawing complex geometric shapes. Geometric shapes are defined by Canvas Widgets. TouchGFX comes with a number of supported <a class="el" href="page_application_development.html#sect_application_development_elements_canvas_widgets">Canvas Widgets</a> but just like normal widgets you can make your own custom Canvas Widget to match your needs. Where a Canvas Widget defines the geometric shape of a figure to be drawn by the CWR, the actual color of each pixel inside the figure is defined by an associated Painter class. Again, TouchGFX comes with a number of <a class="el" href="page_application_development.html#sect_application_development_elements_painters">Painters</a> but you can make your own custom Painters to match your needs.</p>
<p>See <a class="el" href="page_examples.html#sect_canvas_widget_example">CanvasWidget Example</a> for an example.</p>
<div class="image">
<img src="canvas_widgets.png" alt="canvas_widgets.png"/>
<div class="caption">
Example of Canvas Widget objects</div></div>
 <h3><a class="anchor" id="sect_application_development_cwr_using_canvas_widgets"></a>
Using Canvas Widgets</h3>
<p>Other widgets in TouchGFX have their sizes set automatically. A bitmap widget, for example, will automatically get the width and height of the contained bitmap. It is therefore enough use <a class="el" href="classtouchgfx_1_1_drawable_a005377b7638934a36a22fe8a62b1fb53.html#a005377b7638934a36a22fe8a62b1fb53">setXY()</a> on the bitmap widget to place the bitmap on the display.</p>
<p>Canvas Widgets do not have a default size which can be determined automatically and set initially. Care must be taken to not only position, but also size the widget correctly, otherwise the width and height of the Canvas Widget will be to zero, and nothing will be drawn on the display.</p>
<p>So, instead of using <em>setXY()</em>, use <a class="el" href="classtouchgfx_1_1_drawable_a678cf31a4b8ff9da6b37fbf1d2e536c0.html#a678cf31a4b8ff9da6b37fbf1d2e536c0">setPosition()</a> to place and size the canvas widget. See also <a class="el" href="page_application_development.html#sect_application_development_canvas_widgets_custom">Custom Canvas Widgets</a> below for an example on how to create and use a custom canvas widget.</p>
<p>Once the position and size of the Canvas Widget has been set, a geometrical shape can be drawn inside it. The coordinate system will have (0, 0) in the upper left corner of the widget (<em>not</em> the display), the X axis stretches to the right and the Y axis stretches downwards. See <a class="el" href="page_application_development.html#sect_application_development_cwr_coordinate_system">The Coordinate System</a> for further information.</p>
<h3><a class="anchor" id="sect_application_development_cwr_memory"></a>
Memory allocation and usage</h3>
<p>To produce nice anti-aliased complex geometrical shapes requires additional memory. For this CWR has to have a special allocated memory buffer that is used during rendering. CWR, as the rest of TouchGFX, has no dynamic memory allocation.</p>
<p>The memory buffer should be allocated and setup in <code>target/main.cpp</code> (and <code>simulator/main.cpp</code>) as follows &ndash; here are snippets from <code>target/main.cpp</code>. See <code>app/example/canvas_widget_example</code> for further details.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CANVAS_BUFFER_SIZE (3600)</span></div>
</div><!-- fragment --><p> Is defined in the beginning of main.cpp and the following code in main():</p>
<div class="fragment"><div class="line"><span class="comment">// Setup the CanvasWidgetRenderer. ONLY needed if you use CanvasWidgets</span></div>
<div class="line"><span class="comment">// in your application. The CANVAS_BUFFER_SIZE can be adjusted to match</span></div>
<div class="line"><span class="comment">// your needs in performance vs. RAM usage. Read more on this in the</span></div>
<div class="line"><span class="comment">// TouchGFX Manual.</span></div>
<div class="line"><span class="keyword">static</span> uint8_t canvasBuffer[CANVAS_BUFFER_SIZE];</div>
<div class="line">CanvasWidgetRenderer::setupBuffer(canvasBuffer, CANVAS_BUFFER_SIZE);</div>
</div><!-- fragment --><p> <br />
The amount of CWR memory needed depends on the maximum size of the shapes that are to be drawn in the application. You can, however, reserve less memory than the maximum shape requires. To handle this situation the CWR split up drawings of shapes into smaller frame buffer parts resulting in slightly longer rendering time, as shapes in these cases will sometimes have to be rendered more than once. It is possible to investigate and fine-tune the memory consumption closer when running in simulator mode.</p>
<dl class="section note"><dt>Note</dt><dd>Fine tuning the memory buffer size can easily be done from your program by a call to <em><a class="el" href="classtouchgfx_1_1_canvas_widget_renderer_a2a8f444c1114199ab64d6d79f1576adf.html#a2a8f444c1114199ab64d6d79f1576adf" title="Calculate how much memory has been required by CanvasWidgets. ">touchgfx::CanvasWidgetRenderer::getUsedBufferSize()</a></em> and <em><a class="el" href="classtouchgfx_1_1_canvas_widget_renderer_a14c94d800debf92b8dbb50c9c780256d.html#a14c94d800debf92b8dbb50c9c780256d" title="Calculate how much memory was required by CanvasWidgets, but was unavailable. ">touchgfx::CanvasWidgetRenderer::getMissingBufferSize()</a></em>. The sum of these two values is the maximum amount of memory that was required by CWR for the specific execution of the application. This number is easy to monitor with the simulator by simply changing <div class="fragment"><div class="line"><span class="preprocessor">#define CWR_OUTPUT 0</span></div>
</div><!-- fragment --> to <div class="fragment"><div class="line"><span class="preprocessor">#define CWR_OUTPUT 1</span></div>
</div><!-- fragment --> in <em><a class="el" href="classtouchgfx_1_1_canvas_widget_renderer.html" title="Class for supporting drawing of figures. ">touchgfx::CanvasWidgetRenderer</a></em> "CanvasWidgetRenderer.hpp". Now updates to the CWR memory requirements will be printed in the console window.</dd></dl>
<p>Setting the correct memory buffer size is a trade off between memory and performance (rendering time). A good starting value is usually around 3000, but using the above technique, a better value can often be determined. If the shape is too complex and the allocated memory buffer is too small, part of the shape will not be drawn (some vertical pixel lines will be skipped) and it is possible that nothing is drawn at all. In any case rendering time will increase a lot.</p>
<p>If the memory buffer is far too small, CWR will fail. If this happens in debug mode CWR will assert and in release mode CWR will not draw on the display (since the buffers are setup for each draw request, it is possible that sometimes nothing is draw and sometimes parts of the geometrical shapes are drawn with some one or more vertical lines missing).</p>
<h3><a class="anchor" id="sect_application_development_cwr_coordinate_system"></a>
The Coordinate System</h3>
<p>The coordinate system in TouchGFX is normally used to address pixels for positioning bitmaps on the display. Bitmaps, texts and other graphic elements are all placed in a coordinate system, where (0,0) is the upper left hand pixel, the x-axis extends to the right and the y-axis extends downwards. In CWR it is not enough to be able to address pixels using integers, though this might be enough in special cases, this is far from enough in general. To demonstrate this, consider a circle with line width 1, which must fit precisely inside a box of 5 by 5 pixels. The center of this circle must be at (2.5, 2.5) and the radius must be 2, so fractions are required for the center coordinate. Similarly, if the circle should fit inside a box of 6 by 6 pixels, the center must be at (3, 3) and the radius must be 2.5, so here fractions are required for the radius.</p>
<p>This new way of addressing coordinates for drawing graphics, means that the center of the pixel at (0,0) has CWR coordinate (0.5, 0.5). Hence, the box containing the pixel in the upper left corner of the screen has the following outline: (0,0) -&gt; (1,0) -&gt; (1,1) -&gt; (0,1) -&gt; (0,0).</p>
<p>Though this might seem confusing at first, it quickly becomes very natural. Where the coordinate system for bitmaps address the pixels, the same coordinate for Canvas Widgets address the <em>gap</em> just before and above the pixel.</p>
<h3><a class="anchor" id="sect_application_development_canvas_widgets_custom"></a>
Custom Canvas Widgets</h3>
<p>Implementing a custom Canvas Widget requires an implementation of a new class with the following functions: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> drawCanvasWidget(<span class="keyword">const</span> Rect&amp; invalidatedArea) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">virtual</span> Rect getMinimalRect() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The <code>drawCanvasWidget()</code> must draw whatever the custom widget needs to draw and <code>getMinimalRect()</code> should return the actual rectangle in the Widget which contains the geometrical shape. </p><dl class="section note"><dt>Note</dt><dd>The reason for having <code>getMinimalRect()</code> is that a geometrical shape can be moved around inside its widget and it is often impractical to resize and reposition the widget whenever the shape changes to only invalidate the smallest possible area.</dd></dl>
<p>A dummy implementation of <code>getMinimalRect()</code> could simply <code>"return rect;"</code>, that is the size of the widget, but that would cause the entire area covered by the canvas widget to be redrawn, and not just the part of the canvas widget containing the getometrical shape. Very often, the geometrical shape occupies only a small part of the canvas widget, for example the hands of a clock as can be seen in the <a class="el" href="page_demos.html#sect_demo_2014">touchgfx_2014 demo</a>.</p>
<p>Canvas Widgets all use the <a class="el" href="classtouchgfx_1_1_canvas.html">Canvas</a> class, which encapsulates the Canvas Widget Renderer as described above. CWR has many optimizations applied automatically, though awareness of your geometrical shape in relation to the invalidated area, and avoiding unnecessary drawing outside the invalidated area, is always a good way to boost performance.</p>
<p>A rough implementation of a diamond shaped square inside a 10x10 box could look something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Box10x10 : <span class="keyword">public</span> CanvasWidget</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> Rect getMinimalRect()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> Rect(0,0,10,10);</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> drawCanvasWidget(<span class="keyword">const</span> Rect&amp; invalidatedArea)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Canvas canvas(<span class="keyword">this</span>, invalidatedArea);</div>
<div class="line">    canvas.moveTo(5,0);</div>
<div class="line">    canvas.lineTo(10,5);</div>
<div class="line">    canvas.lineTo(5,10);</div>
<div class="line">    canvas.lineTo(0,5);</div>
<div class="line">    <span class="keywordflow">return</span> canvas.render(); <span class="comment">// Shape is automatically closed</span></div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Again, be careful that <code>getMinimalRect()</code> returns to correct rectangle, or the graphics on screen might be wrong.</dd></dl>
<p>In order to see the Box10x10 on the display, the color must be set using <a class="el" href="classtouchgfx_1_1_canvas_widget_a41a51a6fa4a2afa7319585343251108a.html#a41a51a6fa4a2afa7319585343251108a">Box10x10::setPainter()</a> inherited from CanvasWidget. Also, the Box10x10 must be placed and sized correctly. This could look similar to this:</p>
<p>In the header file declare </p><div class="fragment"><div class="line">Box10x10 box;</div>
<div class="line">PainterRGB565 myPainter;</div>
</div><!-- fragment --><p>and in the code you should have something like this: </p><div class="fragment"><div class="line">myPainter.setColor(Color::getColorFrom24BitRGB(0xFF, 0x0, 0x0));</div>
<div class="line">box.setPosition(100,100,10,10);</div>
<div class="line">box.setPainter(myPainter);</div>
<div class="line">add(box);</div>
</div><!-- fragment --><p>The color of the Box10x10 is determined by the Painter currently set on the box object and is handled entirely by the super class. Read more about <a class="el" href="page_application_development.html#sect_application_development_canvas_widget_painters">Painters</a> below.</p>
<p>See <a class="el" href="page_application_development.html#sect_application_development_elements_canvas_widgets">Canvas Widgets</a> for all supported Canvas Widgets.</p>
<h3><a class="anchor" id="sect_application_development_canvas_widget_painters"></a>
Painters</h3>
<p>A Painter defines a coloring scheme to fill a Canvas Widget object. TouchGFX comes with a set of predefined painter classes, but custom painters can easily be implemented.</p>
<p>In order to implement a custom Painter, care must be taken to never write outside the frame buffer. Such a bug in a custom Painter can result in serious crashes. Here is an example of a custom Painter which we will use to paint an object red, only function <a class="el" href="classtouchgfx_1_1_abstract_painter_r_g_b565_a60fc8383ac89092c3ce332ef8acc2116.html#a60fc8383ac89092c3ce332ef8acc2116">renderNext()</a> needs to be implemented. See <a class="el" href="classtouchgfx_1_1_abstract_painter.html">AbstractPainter</a> for more information.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Red : <span class="keyword">public</span> AbstractPainterRGB565</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> renderNext(uint8_t &amp;red, uint8_t &amp;green, uint8_t &amp;blue, uint8_t &amp;alpha)</div>
<div class="line">    {</div>
<div class="line">        red = 0xFF;</div>
<div class="line">        green = 0x00;</div>
<div class="line">        blue = 0x00;</div>
<div class="line">        alpha = 0xFF;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>To paint the box object from above red, put this in the header file: </p><div class="fragment"><div class="line">Box10x10 box;</div>
<div class="line">Red redPaint;</div>
</div><!-- fragment --><p>and put this in the code: </p><div class="fragment"><div class="line">box.setPosition(100,100,10,10);</div>
<div class="line">box.setPainter(redPaint);</div>
<div class="line">add(box);</div>
</div><!-- fragment --><p>Please note that it is possible to override more methods to create special painters (e.g. <a class="el" href="classtouchgfx_1_1_abstract_painter_r_g_b565_aefae2b9d91c5107551402bc23f1d1802.html#aefae2b9d91c5107551402bc23f1d1802">renderInit()</a>), however, TouchGFX has some generic painters which covers most uses, see <a class="el" href="page_application_development.html#sect_application_development_elements_painters">Painters</a> for all supported Painters.</p>
<h2><a class="anchor" id="sect_application_development_mixin"></a>
Mixins</h2>
<p>When developing a TouchGFX applications it is sometimes necessary to apply a particular feature to a lot of different widgets and containers e.g. the ability to get dragged around the screen. A useful method for doing this is to use mixin classes.</p>
<p>A mixin is a fragment of a class in the sense that it is intended to be composed with other classes or mixins and not intended for standalone use.</p>
<p>TouchGFX comes with a set of mixin classes that can be used together with any widget and container. One example is the Draggable mixin class.</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Draggable : <span class="keyword">public</span> T</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Draggable() : T()</div>
<div class="line">    {</div>
<div class="line">        T::setTouchable(<span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> ~Draggable() { }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handleDragEvent(<span class="keyword">const</span> DragEvent&amp; evt)</div>
<div class="line">    {</div>
<div class="line">        T::handleDragEvent(evt);</div>
<div class="line">        T::moveRelative(evt.getDeltaX(), evt.getDeltaY());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><p>The only thing the mixin does is to ensure that the template element is touchable and that its position is updated when receiving drag events. Now if you simply declare your widget or container as the template argument for the mixin class it will receive the new feature from the mixin class.</p>
<p>An example of how to declare your image as draggable:</p>
<div class="fragment"><div class="line">Draggable&lt;Image&gt; myDraggableImage;</div>
</div><!-- fragment --><p> <br />
See <a class="el" href="page_examples.html#sect_drag_example">Drag Example</a> for usage of the <a class="el" href="classtouchgfx_1_1_snapper.html" title="A mix-in that will make class T draggable and able to snap to a position. ">touchgfx::Snapper</a> and <a class="el" href="classtouchgfx_1_1_draggable.html" title="Mix-in class that extends a class to become draggable. ">touchgfx::Draggable</a> mixins.</p>
<h2><a class="anchor" id="sect_application_development_using_text_and_fonts"></a>
Using Text and Fonts</h2>
<p>Displaying texts is a built in capability of TouchGFX. A <a class="el" href="classtouchgfx_1_1_typed_text.html">TypedText</a> in TouchGFX is a combined entity of the text contents itself and the typography of the text. The typography contains, the font and font size of the text and the bits per pixel (bpp) used in anti aliasing the glyphs of the font.</p>
<p>TypedTexts are specified in the <code>assets/texts/texts.xlsx</code> Excel file. The texts.xlsx file supports specifying texts for any language needed. For a complete specification read <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_texts">Text Converter</a>.</p>
<p><a class="el" href="page_examples.html#sect_text_example">Text Example</a> illustrates the key aspects of text displaying in TouchGFX.</p>
<h3><a class="anchor" id="sect_application_development_texts_using"></a>
Using Texts in Code</h3>
<p>In order to display a <a class="el" href="classtouchgfx_1_1_typed_text.html">TypedText</a> on the screen we use the <a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a> widget.</p>
<div class="fragment"><div class="line"><span class="comment">// in the .hpp file</span></div>
<div class="line">TextArea txt;    </div>
<div class="line"></div>
<div class="line"><span class="comment">// in the .cpp file</span></div>
<div class="line">txt.setTypedText(TypedText(T_MAIN_TEXT));</div>
<div class="line">txt.setPosition(...);</div>
<div class="line">txt.setColor(...)</div>
<div class="line">...</div>
<div class="line">add(txt);    </div>
</div><!-- fragment --><p>We set the <a class="el" href="classtouchgfx_1_1_typed_text.html">TypedText</a> of the <a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a> and set the position and color. Finally the <a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a> is added to the current view.</p>
<h3><a class="anchor" id="sect_application_development_texts_wildcards"></a>
Wildcards</h3>
<p><a class="el" href="classtouchgfx_1_1_typed_text.html">TypedTexts</a> can contain "wildcards", making texts with dynamic content possible. This is specified in the texts.xlsx file by using the special syntax &lt;...&gt;. This corresponds closely to having a %s in a regular string in C++.</p>
<p>Using wildcard text in an application is done by managing and updating a local <a class="el" href="classtouchgfx_1_1_unicode_ab3b1deb713ab2c9df4fe1b29e403485f.html#ab3b1deb713ab2c9df4fe1b29e403485f">touchgfx::Unicode::UnicodeChar</a> array.</p>
<div class="fragment"><div class="line"><span class="comment">// in the .hpp file</span></div>
<div class="line">TextAreaWithOneWildcard txt;</div>
<div class="line">Unicode::UnicodeChar txtBuffer[10];</div>
<div class="line"></div>
<div class="line"><span class="comment">// in the .cpp file</span></div>
<div class="line">...</div>
<div class="line">txt.setWildcard(txtBuffer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// updating the value</span></div>
<div class="line">Unicode::snprintf(txtBuffer, 10, <span class="stringliteral">&quot;%d&quot;</span>, 42);</div>
<div class="line">txt.invalidate();   </div>
</div><!-- fragment --><p>See <a class="el" href="page_examples.html#sect_text_example">Text Example</a> for a complete example.</p>
<p>Note that you have to make sure that all characters used in a wildcard are represented in the texts.xlsx file for that wildcards specific typography. As an example if you need to display digits, make sure that characters corresponding to the digits 0 to 9 are present in the texts.xlsx file (for that typography).</p>
<p>Also note that two consecutive <code>%</code> chars will be replaced by one <code>%</code> char in wildcard strings.</p>
<h3><a class="anchor" id="sect_application_development_texts_switch"></a>
Switching Language</h3>
<p>TouchGFX supports multi language interfaces. The current language used in the interface can be changed by </p><div class="fragment"><div class="line">Texts::setLanguage(...);</div>
</div><!-- fragment --><h3><a class="anchor" id="sect_application_development_texts_conversion"></a>
Conversion Process</h3>
<p>Texts are automatically transformed from Excel (.xlsx) to an internal .cpp format. Likewise fonts are transformed from TrueType/OpenType/Glyph Bitmap Distribution Format (.ttf/.otf/.bdf) to an internal .cpp format. This is done when invoking make or make assets and utilizes the supplied textconvert and fontconvert tools. See <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools">Assets and Tools</a> for more information.</p>
<p>The texts located in the assets/texts folder are converted and placed in the generated/texts folder. The fonts located in the assets/fonts folder are converted and placed in the generated/fonts folder.</p>
<p>The generated texts are all inserted into a database. The texts are named after the keys in the Excel file and can be found in the generated file <code>generated/texts/include/texts/TextKeysAndLanguages.hpp</code>.</p>
<p>All a developer has to worry about is placing the needed texts in the <code>assets/texts/texts.xlsx</code> file. The rest will be handled by the TouchGFX tooling.</p>
<p><em>Note:</em> Some Glyph Bitmap Distribution Format (.bdf) files have been seen to contain lines with leading spaces causing problems for the font convert utility. The .bdf font file can simply be edited using any text editor and those leading spaces can be removed thereby correcting the .bdf font file.</p>
<h2><a class="anchor" id="sect_application_development_using_images"></a>
Using Images</h2>
<p>Images are essential since a lot of the graphical elements in a typical TouchGFX application are based on images. The following sections provides an overview of how an image is represented in TouchGFX and how it is used.</p>
<h3><a class="anchor" id="sect_application_development_images_in_code"></a>
Using Images in Code</h3>
<p>The <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a> class is a proxy for images stored in the application specific bitmap database that holds the auto generated images. The <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a> can be used to build a GUI by using it with the following classes:</p><ul>
<li><a class="el" href="classtouchgfx_1_1_image.html">Image</a></li>
<li><a class="el" href="classtouchgfx_1_1_animated_image.html">AnimatedImage</a></li>
<li><a class="el" href="classtouchgfx_1_1_button.html">Button</a></li>
<li><a class="el" href="classtouchgfx_1_1_toggle_button.html">ToggleButton</a></li>
</ul>
<p>A <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a> object is instantiated by passing the constructor an ID that identifies the bitmap in the bitmap database the <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a> should be a proxy for.</p>
<p><a class="el" href="classtouchgfx_1_1_image.html">Image</a> is one of the classes using the <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a>. To use an <a class="el" href="classtouchgfx_1_1_image.html">Image</a>, and thus a <a class="el" href="classtouchgfx_1_1_bitmap.html">Bitmap</a>, it is necessary to include the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/widgets/Image.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;BitmapDatabase.hpp&gt;</span></div>
</div><!-- fragment --><p>Assuming that the BitmapDatabase contains the ID BITMAP_BACKGROUND_ID, it is possible to use this ID to create an <a class="el" href="classtouchgfx_1_1_image.html">Image</a> as shown below:</p>
<div class="fragment"><div class="line">Image someImage(Bitmap(BITMAP_BACKGROUND_ID));</div>
</div><!-- fragment --><p>When <em>someImage</em> is drawn by the framework, it will now show the bitmap image that BITMAP_BACKGROUND_ID identifies.</p>
<p>TouchGFX supports referencing the same bitmap multiple times and thus it is valid to do the following:</p>
<div class="fragment"><div class="line">Image someImage(Bitmap(BITMAP_BACKGROUND_ID));</div>
<div class="line">Image anotherImage(Bitmap(BITMAP_BACKGROUND_ID));</div>
</div><!-- fragment --><p>As described in <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_images">Image Converter</a> images may include alpha blended pixels. Furthermore it is possible to dynamically set a transparency level, the alpha value, of an entire image when using images.</p>
<div class="fragment"><div class="line">Image image;</div>
<div class="line">...</div>
<div class="line">image.setAlpha(123);</div>
</div><!-- fragment --><h3><a class="anchor" id="sect_application_development_images_conv"></a>
The Conversion Process</h3>
<p>Images are automatically transformed from one of the supported image formats to the internal 16 bit cpp representation. This is done when building in Visual Studio, invoking make or make assets and utilizes the supplied imageconvert tool. For detailed information see <a class="el" href="page_application_development.html#sect_application_development_assets_and_tools_images">Image Converter</a>.</p>
<p>The generated bitmaps are all inserted into a database (<code>generated/images/include/BitmapDatabase.hpp</code>). The bitmaps are named after the input image files. As an example the assets/images/background.bmp file is converted to the BITMAP_BACKGROUND_ID bitmap. Another example is assets/images/icons/open.png being converted to BITMAP_OPEN_ID bitmap. Note that the directory name 'icons' is not included in the name of the generated bitmap.</p>
<p>As a consequence all a developer has to worry about is placing the needed image files in the assets/images folder. The rest will be handled by the TouchGFX tooling.</p>
<h2><a class="anchor" id="sect_application_development_using_callbacks"></a>
Using Callbacks</h2>
<p>A Callback in TouchGFX is essentially a function pointer wrapper which enables the registration of a function to be called when something happens. For instance, the <a class="el" href="classtouchgfx_1_1_button.html">Button</a> standard widget can be configured to call a function when the button is clicked. Naturally the callback mechanism can also be used for custom widgets in the application.</p>
<p>The reason TouchGFX does not use simple function pointers is that we want the function to be called to be able to reside as a member function of a user-created class. In C++ pointers to member functions require knowledge of the class from the caller, which is problematic for standard widgets. For instance, consider that a standard Button needs to invoke a member function of your custom View subclass, of which it has no knowledge.</p>
<p>To deal with this, a template-based abstraction has been implemented. It is based on two parts: a <a class="el" href="classtouchgfx_1_1_generic_callback.html">GenericCallback</a> placed in the caller (e.g. Button), and a <a class="el" href="structtouchgfx_1_1_callback.html">Callback</a> placed in the callee (e.g. your custom view). The GenericCallback does not require knowledge of the class type of the member function, meaning it can be used in standard widgets. Callbacks can be configured to call functions of zero, one or two parameters.</p>
<p>The syntax of callbacks is a bit cumbersome but the added value that the function being called can be placed in a member function usually makes it worthwhile. For instance, a button clicked handler will very often need to manipulate other widgets in the View or notify the Presenter, both of which requires access to other View member variables. Using a normal function pointer to a global function instead of a Callback will require some other mechanism of manipulating the view from outside. You are of course free to employ whatever callback mechanism you wish in your custom widgets and views.</p>
<p>The following is an example of how to declare the two portions of a callback and glue them together:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/Callback.hpp&gt;</span></div>
<div class="line"><span class="comment">// This is a widget capable of firing an event. You can register a callback to catch the event.</span></div>
<div class="line"><span class="keyword">class </span>MyWidget : <span class="keyword">public</span> Widget</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyWidget() : action(0) {} <span class="comment">//Make sure to initialize listener pointer to zero</span></div>
<div class="line">  <span class="comment">// This function registers the callback</span></div>
<div class="line">  <span class="keywordtype">void</span> setAction(<a class="code" href="classtouchgfx_1_1_generic_callback.html">GenericCallback&lt;&gt;</a>&amp; callback) { action = &amp;callback; }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// This function calls the callback, if one is registered.</span></div>
<div class="line">  <span class="keywordtype">void</span> fire()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (action &amp;&amp; action-&gt;isValid())</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Call registered function</span></div>
<div class="line">      action-&gt;<a class="code" href="classtouchgfx_1_1_generic_callback_aa7e70d5830870ffa6582687ca32ffc24.html#aa7e70d5830870ffa6582687ca32ffc24">execute</a>();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">//An untyped pointer to the typed Callback located in callee</span></div>
<div class="line">  <a class="code" href="classtouchgfx_1_1_generic_callback.html">GenericCallback&lt;&gt;</a>* action; </div>
<div class="line">};</div>
</div><!-- fragment --><p>On the receiver side, where the function to be called is located, it looks like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/Callback.hpp&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyView : <span class="keyword">public</span> View</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyView() : </div>
<div class="line">    cb(this, &amp;MyView::handleEvent) <span class="comment">// Initialize callback with pointer to object containing member function, and address of member function.</span></div>
<div class="line">  {</div>
<div class="line">    myWidget.setAction(cb); <span class="comment">//Register callback</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> handleEvent() </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//This function gets called when event is fired from MyWidget</span></div>
<div class="line">  } </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  MyWidget myWidget;</div>
<div class="line">  Callback&lt;MyView&gt; cb; <span class="comment">//This callback is for a function placed in MyView</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>As mentioned, callbacks are also defined for calling functions with one or two parameters. An example where the function takes an integer argument is as follows: </p><div class="fragment"><div class="line">  GenericCallback&lt;int&gt;* action; </div>
<div class="line">  <span class="keywordtype">void</span> setAction(GenericCallback&lt;int&gt;&amp; callback) { action = &amp;callback; }</div>
<div class="line">  <span class="keywordtype">void</span> fire(<span class="keywordtype">int</span> eventCode)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (action &amp;&amp; action-&gt;isValid())</div>
<div class="line">    {</div>
<div class="line">      action-&gt;execute(eventCode);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">  MyView() : cb(this, &amp;handleEvent) {}</div>
<div class="line">  Callback&lt;MyView, int&gt; cb;</div>
<div class="line">  <span class="keywordtype">void</span> handleEvent(<span class="keywordtype">int</span> value) {}</div>
<div class="line">  myWidget.setAction(cb);</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sect_application_development_elements"></a>
Widgets, Containers, Mixins, Canvas Widgets</h1>
<p>The TouchGFX distribution provides a set of built-in widgets, containers, mixins, Canvas Widgets and Painters. The complete set is:</p>
<h2><a class="anchor" id="sect_application_development_elements_widgets"></a>
Widgets</h2>
<ul>
<li><a class="el" href="classtouchgfx_1_1_abstract_button.html">AbstractButton</a></li>
<li><a class="el" href="classtouchgfx_1_1_animated_image.html">AnimatedImage</a></li>
<li><a class="el" href="classtouchgfx_1_1_box.html">Box</a></li>
<li><a class="el" href="classtouchgfx_1_1_button.html">Button</a></li>
<li><a class="el" href="classtouchgfx_1_1_button_with_icon.html">ButtonWithIcon</a></li>
<li><a class="el" href="classtouchgfx_1_1_button_with_label.html">ButtonWithLabel</a></li>
<li><a class="el" href="classtouchgfx_1_1_image.html">Image</a></li>
<li><a class="el" href="classtouchgfx_1_1_keyboard.html">Keyboard</a></li>
<li><a class="el" href="classtouchgfx_1_1_radio_button.html">RadioButton</a></li>
<li><a class="el" href="classtouchgfx_1_1_radio_button_group.html">RadioButtonGroup</a></li>
<li><a class="el" href="classtouchgfx_1_1_scalable_image.html">ScalableImage</a></li>
<li><a class="el" href="classtouchgfx_1_1_snapshot_widget.html">SnapshotWidget</a></li>
<li><a class="el" href="classtouchgfx_1_1_text_area.html">TextArea</a></li>
<li><a class="el" href="classtouchgfx_1_1_text_area_with_one_wildcard.html">TextAreaWithOneWildcard</a></li>
<li><a class="el" href="classtouchgfx_1_1_text_area_with_two_wildcards.html">TextAreaWithTwoWildcards</a></li>
<li><a class="el" href="classtouchgfx_1_1_texture_mapper.html">TextureMapper</a></li>
<li><a class="el" href="classtouchgfx_1_1_toggle_button.html">ToggleButton</a></li>
<li><a class="el" href="classtouchgfx_1_1_touch_area.html">TouchArea</a></li>
</ul>
<h2><a class="anchor" id="sect_application_development_elements_containers"></a>
Containers</h2>
<ul>
<li><a class="el" href="classtouchgfx_1_1_container.html">Container</a></li>
<li><a class="el" href="classtouchgfx_1_1_list_layout.html">ListLayout</a></li>
<li><a class="el" href="classtouchgfx_1_1_scrollable_container.html">ScrollableContainer</a></li>
<li><a class="el" href="classtouchgfx_1_1_slider.html">Slider</a></li>
<li><a class="el" href="classtouchgfx_1_1_zoom_animation_image.html">ZoomAnimationImage</a></li>
</ul>
<h2><a class="anchor" id="sect_application_development_elements_mixins"></a>
Mixins</h2>
<ul>
<li><a class="el" href="classtouchgfx_1_1_click_listener.html">ClickListener</a></li>
<li><a class="el" href="classtouchgfx_1_1_draggable.html">Draggable</a></li>
<li><a class="el" href="classtouchgfx_1_1_fade_animator.html">FadeAnimator</a></li>
<li><a class="el" href="classtouchgfx_1_1_move_animator.html">MoveAnimator</a></li>
<li><a class="el" href="classtouchgfx_1_1_pre_renderable.html">PreRenderable</a></li>
<li><a class="el" href="classtouchgfx_1_1_snapper.html">Snapper</a></li>
</ul>
<p>To read more on extending or creating widget, containers and mixins please read <a class="el" href="page_application_development.html#sect_application_development_customwidgets">Custom Widgets and Containers</a>.</p>
<h2><a class="anchor" id="sect_application_development_elements_canvas_widgets"></a>
Canvas Widgets</h2>
<ul>
<li><a class="el" href="classtouchgfx_1_1_circle.html">Circle</a></li>
<li><a class="el" href="classtouchgfx_1_1_line.html">Line</a></li>
<li><a class="el" href="classtouchgfx_1_1_shape.html">Shape</a></li>
</ul>
<h2><a class="anchor" id="sect_application_development_elements_painters"></a>
Painters</h2>
<ul>
<li><a class="el" href="classtouchgfx_1_1_painter_b_w.html">PainterBW</a></li>
<li><a class="el" href="classtouchgfx_1_1_painter_r_g_b565.html">PainterRGB565</a></li>
<li><a class="el" href="classtouchgfx_1_1_painter_r_g_b565_bitmap.html">PainterRGB565Bitmap</a></li>
</ul>
<p>To read more on extending or creating canvas widgets and painters please read <a class="el" href="page_application_development.html#sect_application_development_canvas_widgets">Canvas Widgets</a>.</p>
<p>More widgets, containers, and mixins can be found in the TouchGFX Open Repository (see <a class="el" href="page_application_development.html#sect_application_development_open_repository">TouchGFX Open Repository</a>).</p>
<h1><a class="anchor" id="sect_application_development_open_repository"></a>
TouchGFX Open Repository</h1>
<p>TouchGFX includes an open source community that shares custom widget, containers, and other components that can be used free of charge either directly in your application or as inspiration. The source code is directly accessible from the GitHub <a href="https://github.com/draupnergraphics/touchgfx-open-repository">web page</a>.</p>
<p>The TouchGFX Open Repository can be found <a href="https://github.com/draupnergraphics/touchgfx-open-repository">here</a>.</p>
<p>The TouchGFX team would like to encourage you to use the repository and contribute with your own great ideas and widgets whenever possible.</p>
<h1><a class="anchor" id="sect_application_development_misc"></a>
Miscellaneous</h1>
<h2><a class="anchor" id="sect_application_development_screenshots"></a>
Screenshots</h2>
<p>The simulator supports taking screenshots of the current screen. Use the F3 key to do this. The screenshots will be saved in the <code>screenshots/</code> folder. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
