<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TouchGFX: Porting Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="touchgfx.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="touchgfxlogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TouchGFX
   &#160;<span id="projectnumber">v4.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_porting.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Porting Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page details the steps involved to port TouchGFX to a custom hardware platform. Understanding and following the porting procedure detailed in this guide will allow you to run TouchGFX applications on hardware platforms other than the ones immediately supported by the TouchGFX distribution. We recommend that you understand the following advanced topics before proceeding:</p><ul>
<li><a class="el" href="page_advanced.html#sect_adv_timing">Timing and TFT Controller Integration</a><ul>
<li><a class="el" href="page_advanced.html#sect_adv_timing_rendering">Rendering Pass</a></li>
<li><a class="el" href="page_advanced.html#sect_adv_timing_framerate">Frame Rate</a></li>
<li><a class="el" href="page_advanced.html#sect_adv_timing_framebuffers">Number of Frame Buffers</a></li>
</ul>
</li>
<li><a class="el" href="page_advanced.html#sect_adv_blitcaps">Blitting Operations and Hardware Blit Capabilities</a></li>
</ul>
<p>The hardware abstraction layer of TouchGFX is split into several components, dealing with various aspects of hardware interaction. If the target platform uses the same hardware as the evaluation board abstraction layers in the TouchGFX distribution, the porting effort is simply to pick and combine the appropriate hardware components already implemented. If the target platform differs in one or more areas, some of the TouchGFX HAL components must be implemented to fit this specific hardware. For the sake of completeness this guide will cover the process of implementing all the components of the TouchGFX hardware abstraction, but chances are you will be able to skip at least some chapters, provided that you choose already supported hardware components for your design.</p>
<p>In general terms, a typical hardware platform will consist of the following:</p><ul>
<li>An MCU with a TFT controller and optionally DMA capabilities to efficiently transfer graphics data</li>
<li>External RAM for frame buffers</li>
<li>External memory-mapped flash for storing graphics data</li>
<li>A TFT display, with resistive or capacitive touch</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If the external flash is not memory-mapped, see <a class="el" href="page_porting.html#sect_porting_altflash">Non-memory mapped external flash / Supporting bitmap caching</a>. <br />
<br />
</dd>
<dd>
If your display is 1BPP monochrome, see <a class="el" href="page_advanced.html#sect_adv_monochrome">Configuring TouchGFX for 1BPP Monochrome</a> <br />
<br />
</dd>
<dd>
If your MCU does not have a TFT controller, see <a class="el" href="page_porting.html#sect_porting_notft">MCUs without TFT controller</a></dd></dl>
<h1><a class="anchor" id="sect_rec_apr"></a>
Recommended Approach</h1>
<p>The task of porting TouchGFX will quickly become almost unmanageable if simply attempting to make everything work in one fell swoop. Instead we recommend the following gradual approach, that adds on portions of TouchGFX functionality through a number of steps. As previously mentioned, depending on your platform, you might be able to skip a few or even all these steps.</p>
<ol type="1">
<li><a class="el" href="page_porting.html#sect_barebone">Initial system</a> (without TouchGFX)<ol type="a">
<li><a class="el" href="page_porting.html#sect_bbu">Board Bring-up</a></li>
<li><a class="el" href="page_porting.html#sect_pinconfig">LCD Pin Configuration</a></li>
<li><a class="el" href="page_porting.html#sect_tftinit">TFT controller initialization</a></li>
<li><a class="el" href="page_porting.html#sect_simpletest">Simple Display Test</a></li>
</ol>
</li>
<li><a class="el" href="page_porting.html#sect_basic_touchgfx">Minimalistic TouchGFX System</a> with software rendering from internal flash<ol type="a">
<li><a class="el" href="page_porting.html#sect_basic_mcu">MCU Component</a></li>
<li><a class="el" href="page_porting.html#sect_basic_oswrappers">OS Abstraction Layer</a></li>
<li><a class="el" href="page_porting.html#sect_basic_boardconfig">BoardConfiguration (Wiring Things Together)</a></li>
<li><a class="el" href="page_porting.html#sect_basic_lcdint">Installing LCD Interrupt Handler</a></li>
</ol>
</li>
<li><a class="el" href="page_porting.html#sect_port_extflash">Placing Graphics Data in External Flash</a></li>
<li><a class="el" href="page_porting.html#sect_port_touch">Touch Driver</a></li>
<li>Add a <a class="el" href="page_porting.html#sect_comp_dma">DMA Component</a></li>
<li><a class="el" href="page_porting.html#sect_port_gpio">Adding a GPIO implementation</a></li>
</ol>
<h1><a class="anchor" id="sect_barebone"></a>
Initial system</h1>
<p>A stable, initial configuration with a working operating system and display is a good place to start before adding TouchGFX code to your project. This chapter deals with the basic system configuration needed before integrating TouchGFX. However, the topic of initializating the MCU clock domains and peripherals is somewhat out of scope, so it is only discussed in general terms here.</p>
<h2><a class="anchor" id="sect_bbu"></a>
Board Bring-up</h2>
<p>Hardware initialization usually consists of the following:</p><ul>
<li>Configure the MCU to use the appropriate clock domain, most likely such that the MCU runs at the highest possible frequency.</li>
<li>Configure the external memory controller(s) such that the external RAM and external flash are accessible. Since external memory generally is the bottleneck of any graphics system, it is quite important that the bus settings are tuned to high performance.</li>
<li>Configure the MCU pins connected to the display.</li>
<li>Configure the TFT controller.</li>
</ul>
<p>The main reason these tasks are kept outside of TouchGFX components is that many projects already have a mechanism for hardware initialization and maybe even a software framework for dealing with HAL access. Naturally, if the target platform uses an MCU and memories already supported by TouchGFX, you can grab the hardware initialization code from one of the evaluation board packages and use that.</p>
<h2><a class="anchor" id="sect_pinconfig"></a>
LCD Pin Configuration</h2>
<p>The appropriate MCU pins must be configured to function as LCD interface pins. That includes the RGB data pins and control signals (PIXELCLOCK, HSYNC, VSYNC, DE). You will probably also need to configure a backlight control pin. These are normally connected to a PWM-capable output which can initially be set to full duty cycle or used as a simple general purpose digital output to obtain maximum backlight intensity.</p>
<h2><a class="anchor" id="sect_tftinit"></a>
TFT controller initialization</h2>
<p>Configuration of the TFT controller varies depending on platform hardware because peripheral registers and display timings vary across MCU families and displays. As such, this is a general description of the concepts involved in initializing TFT controllers for TouchGFX application, which can hopefully aid in the configuration of your concrete platform.</p>
<p>We recommend that you take a look at the <a class="el" href="page_advanced.html#sect_adv_timing">Timing and TFT Controller Integration</a> diagram to understand the basic concepts of porches vs. active area and their effect on VSYNC,HSYNC signals.</p>
<p>A TFT controller normally needs to know the following:</p><ul>
<li><em>Frame buffer address</em>. Set this to the start address of the block of external memory you will want to use for frame buffers.</li>
<li><em>Color format</em>. This should be 16-bit, RGB565. There is usually also a flag to control the color ordering (BGR vs RGB).</li>
<li><em>Interrupts</em>. These must not occur until TouchGFX is properly initialized, so leave them off initially. The <a class="el" href="page_porting.html#sect_basic_mcu">MCU Component</a> will configure these later.</li>
<li><em>Clock source</em>. Consult the display datasheet/manual for the acceptable pixel clock frequency range. You will normally want the pixel clock to run as fast as the display accepts. This might require the use of clock divider mechanisms of the MCU. A typical value could be around 34MHz.</li>
<li><em>Back porches</em>. These define the vertical and horizontal delays between VSYNC/HSYNC signals and actual data (the active area). Back porch values must normally be a specific number of pixel clocks for the image to appear at the correct position on the display. Consult the display datasheet for correct values.</li>
<li><em>Front porches</em>. These delays can be modified to obtain the desired VSYNC frequency. You should aim for front porch settings which yield a VSYNC approx. every 17-20ms.</li>
<li><em>Arbitration priority</em>. Not usually a setting of the TFT controller itself, but some MCUs allow configuring the access priority in case several bus masters wish to access e.g. the external memory simultaneously. It is important that the TFT controller has a high priority in this case, as starvation will lead to visible frame errors.</li>
</ul>
<h2><a class="anchor" id="sect_simpletest"></a>
Simple Display Test</h2>
<p>With the TFT controller running, a simple color test can help verify the correctness of the configuration. Fill the entire frame buffer region with various 16-bit color values using memcpy: </p><div class="fragment"><div class="line">uint16_t black = 0x0;</div>
<div class="line">uint16_t white = 0xFFFF;</div>
<div class="line">uint16_t red   = 0xF800;</div>
<div class="line">uint16_t green = 0x7E0;</div>
<div class="line">uint16_t blue  = 0x1D;</div>
</div><!-- fragment --><p>Note that it might be necessary to also configure or tweak the display itself. This is usually done by setting parameters through an SPI interface to the display. In most cases however the standard configuration pre-programmed by the display manufacturer will work just fine. Consult the display manual for information on how to tune it if necessary.</p>
<h1><a class="anchor" id="sect_basic_touchgfx"></a>
Minimalistic TouchGFX System</h1>
<p>With a basic TFT configuration running, the next step is to create a basic TouchGFX port and integrate it into your project. TouchGFX itself expects the hardware initialization from the previous steps to be done before TouchGFX is initialized, so keep the configuration of clocks, pins, external memory, and TFT controller from the simple display test.</p>
<p>A TouchGFX port is made up of several components. A number of these already exist for a range of hardware platforms and can be reused if they match yours. To get TouchGFX up and running you will need a working MCU component, an OS abstraction layer implementation, a DMA component and finally some TouchGFX initialization code to tie everything together.</p>
<p>Before starting the actual port, you should create a very simple TouchGFX application, consisting of a single screen showing just a full-screen <a class="el" href="classtouchgfx_1_1_box.html">touchgfx::Box</a> widget of some color. You can base your test application on the EmptyApplication found under app/template (see <a class="el" href="page_application_development.html#sect_application_development_creating_new_app">Creating a New Application</a>). Verify using the <a class="el" href="page_build_and_execute.html#sect_build_and_execute_simulator">PC Simulator</a> that the test application works as intended (remember to modify the simulator/main.cpp file to reflect the display resolution of your platform).</p>
<h2><a class="anchor" id="sect_basic_mcu"></a>
MCU Component</h2>
<p>The MCU component is an MCU specific (or MCU-family specific) subclass of the generic <a class="el" href="classtouchgfx_1_1_h_a_l.html">touchgfx::HAL</a> class. It has two responsibilities: controlling interrupts, and interfacing with the frame buffer address register of the TFT controller. To create an MCU component, you simply need to create a HAL subclass and provide implementation for the six pure virtual functions of the base class. Care has been taken to make sure these functions are as simple as possible.</p>
<p>The following MCU components are already available in <a class="el" href="page_the_touchgfx_distribution.html">The TouchGFX Distribution</a> :</p><ul>
<li><b>NXP LPC1788</b> (<code>include/platform/hal/nxp/mcu/LPC17xx/NXP1788HAL.hpp</code>)</li>
<li><b>NXP LPC43xx series</b> (<code>include/platform/hal/nxp/mcu/LPC43xx/NXP43XXHAL.hpp</code>)</li>
<li><b>NXP LPC18xx series</b> (<code>include/platform/hal/nxp/mcu/LPC18xx/NXP18xxHAL.hpp</code>)</li>
<li><b>ST STM32F429/STM32F439</b> (<code>include/platform/hal/ST/mcu/stm32f4x9/STM32F4HAL.hpp</code>)</li>
<li><b>Freescale K70</b> (<code>include/platform/hal/Freescale/mcu/MK70F12/FreescaleK70HAL.hpp</code>)</li>
</ul>
<p>The pure virtual functions that need to be implemented are:</p>
<table class="doxtable">
<tr>
<th>Function </th><th>Purpose  </th></tr>
<tr>
<td>configureInterrupts() </td><td><b>Configure the priorities of the DMA interrupt and the LCD/TFT controller interrupt.</b><br />
 This function must ensure that the priorities of the DMA and TFT interrupts are <em>the same</em>. Both interrupt vector routines will access TouchGFX internal state information, and if either ISR preempts the other, race conditions can occur. It is therefore quite important that these two interrupts are configured to be processed in a tail-chained/round-robin manner.<br />
 <em>Note:</em> On Cortex-M, some RTOSes require that their API functions are never called from interrupt contexts with a higher priority than those used by the OS itself (usually the SVC interrupt). E.g. if using FreeRTOS on Cortex-M, make sure the priorities set by this function for DMA and TFT interrupts are <em>functionally</em> lower (on Cortex-M this means numerically higher) than configMAX_SYSCALL_INTERRUPT_PRIORITY defined in FreeRTOSConfig.h. Otherwise consult your RTOS documentation to determine whether this requirement is present.   </td></tr>
<tr>
<td>enableLCDControllerInterrupt() </td><td>This function must configure the TFT controller to produce an interrupt on VSYNC.<br />
 <em>Note:</em> This function will automatically be called by TouchGFX once the framework has been properly initialized and is ready to receive interrupts. Make sure TFT controller interrupts at an earlier time than this.   </td></tr>
<tr>
<td>disableInterrupts() </td><td>This function must disable both the DMA and LCD interrupt vectors (in the NVIC for Cortex-M devices). Used by TouchGFX to temporarily guard critical sections.  </td></tr>
<tr>
<td>enableInterrupts() </td><td>This function must enable both the DMA and LCD interrupt vectors (in the NVIC for Cortex-M devices). Used by TouchGFX to temporarily guard critical sections.  </td></tr>
<tr>
<td>getTFTFrameBuffer() </td><td>This function must return the start address of the frame buffer currently being used by the TFT controller. Typically implemented by simply returning the peripheral register containing the frame buffer start address.  </td></tr>
<tr>
<td>setTFTFrameBuffer() </td><td>This function must set the start address of the frame buffer to be used by the TFT controller. Typically implemented by setting the peripheral register containing frame buffer start address.  </td></tr>
</table>
<h2><a class="anchor" id="sect_basic_oswrappers"></a>
OS Abstraction Layer</h2>
<p>In TouchGFX, the <a class="el" href="classtouchgfx_1_1_o_s_wrappers.html">touchgfx::OSWrappers</a> component is a single class that serves as an OS abstraction layer. TouchGFX provides an implementation for FreeRTOS which you can use if that is your operating system, otherwise you need to provide an implementation for the specific operating system you use. The use of OS features is kept to a minimum and it should be possible to implement this component with relative ease. The implementation requires two synchronization points which can be implemented as binary semaphores, mutexes or queues (with a size of 1) depending on your operating system. The synchronization points are:</p>
<h3><a class="anchor" id="sect_oswrappers_vsync"></a>
VSYNC signaling</h3>
<p>The GUI task is synchronized with the occurence of VSYNC events by the TFT controller. This is done in practice by having the GUI task wait on a semaphore/queue/mutex (through <a class="el" href="classtouchgfx_1_1_o_s_wrappers_a2514887814683a91594f7387ec1996ef.html#a2514887814683a91594f7387ec1996ef">waitForVSync</a>). The TFT interrupt routine, which is fired when a VSYNC is created, will post to this semaphore (through <a class="el" href="classtouchgfx_1_1_o_s_wrappers_a253ad7861870970c0165804b00ff7326.html#a253ad7861870970c0165804b00ff7326">signalVSync</a>) which will cause the GUI task to be scheduled in.</p>
<h3><a class="anchor" id="sect_osrappers_fb"></a>
Frame Buffer Access</h3>
<p>Access to the frame buffer needs to be synchronized because both the GUI task and the processor DMA engine may draw in the frame buffer in parallel.</p>
<p>The functions that need to be implemented in OSWrappers are: </p><table class="doxtable">
<tr>
<th>Function </th><th>Purpose  </th></tr>
<tr>
<td>initialize() </td><td>Create the two binary semaphores/mutexes/queues  </td></tr>
<tr>
<td>signalVSync </td><td>Signal that a VSYNC has occured. Should make the vsync queue/mutex available.<br />
 <em>Note:</em> This function is called from an ISR, and should (depending on OS) trigger a scheduling   </td></tr>
<tr>
<td>waitForVSync() </td><td>This function blocks until a VSYNC occurs.<br />
 <em>Note:</em> This function must first clear the mutex/queue and then wait for the next one to occur.   </td></tr>
<tr>
<td>takeFrameBufferSemaphore() </td><td>Take the frame buffer semaphore. Blocks until semaphore is available.  </td></tr>
<tr>
<td>tryTakeFrameBufferSemaphore() </td><td>Attempt to obtain the frame buffer semaphore. If semaphore is not available, do nothing.<br />
 <em>Note:</em> Must return immediately.   </td></tr>
<tr>
<td>giveFrameBufferSemaphore() </td><td>Release the frame buffer semaphore  </td></tr>
<tr>
<td>giveFrameBufferSemaphoreFromISR </td><td>Release the frame buffer semaphore in a way that is safe in interrupt context.<br />
 <em>Note:</em> Called from ISR.  </td></tr>
</table>
<h2><a class="anchor" id="sect_basic_lcdint"></a>
Installing LCD Interrupt Handler</h2>
<p>The LCD interrupt handler drives the timing that triggers event processing and frame endering in TouchGFX. Most TFT controllers will have a single interrupt vector associated, which can be configured to trigger on various timing events within the controller. There are two distinct TFT controller events that need to be handled in TouchGFX context: One is VSYNC, which is used to begin the rendering pass of the next frame. The second one is vertical front porch entry (meaning that the display update procedure has <em>just</em> completed). When this occurs, TouchGFX can begin transferring the DMA queue. Since we are not yet using DMA the latter is not important for now, but we might as well configure it anyway. For a diagram of when these two events occur, see <a class="el" href="page_advanced.html#sect_adv_timing">Timing and TFT Controller Integration</a>.</p>
<p>The following pseudo code illustrates a typical implementation of the LCD controller interrupt handler: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">__irq <span class="keywordtype">void</span> LCD_IRQHandler( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (int_src == VSYNC) <span class="comment">//Determine if interrupt was caused by VSYNC</span></div>
<div class="line">  {</div>
<div class="line">      <span class="comment">// This will signal the GUI task to begin processing a new frame.</span></div>
<div class="line">      OSWrappers::signalVSync(); </div>
<div class="line">      <span class="comment">// Configure TFT controller to fire interrupt on porch</span></div>
<div class="line">      setIntSourcePorch();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (int_src == FRONTPORCH) <span class="comment">// Interrupt caused by entering front porch area.</span></div>
<div class="line">  {</div>
<div class="line">      <span class="comment">// This will signal the framework that the DMA queue can be safely started.</span></div>
<div class="line">      HAL::getInstance()-&gt;frontPorchEntered(); </div>
<div class="line">      <span class="comment">// Configure TFT controller to fire interrupt on VSYNC</span></div>
<div class="line">      setIntSourceVSYNC();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sect_basic_boardconfig"></a>
BoardConfiguration (Wiring Things Together)</h2>
<p>Now that the mandatory components have been created, it is time to get TouchGFX up and running. What we usually do is create a BoardConfiguration.cpp file which contains approximately the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;common/TouchGFXInit.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/BoardConfiguration.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/OSWrappers.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/NoDMA.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;platform/driver/lcd/LCD16bpp.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;platform/driver/touch/NoTouchController.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;path/to/MCUComponent.hpp&gt;</span> <span class="comment">//Modify to reflect location of your MCU component (HAL subclass)</span></div>
<div class="line"></div>
<div class="line">NoDMA dma; <span class="comment">//Initially we do not want DMA support</span></div>
<div class="line">NoTouchController tc; <span class="comment">//Likewise we do not want touch input (yet).</span></div>
<div class="line">LCD16bpp display;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespacetouchgfx_acf938165e604a675fe09218a1b3cfb5f.html#acf938165e604a675fe09218a1b3cfb5f">hw_init</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Hardware initialization code from step 1.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespacetouchgfx_ae6e21dbb033844e61723026bf9b9a4ad.html#ae6e21dbb033844e61723026bf9b9a4ad">touchgfx_init</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//Instantiate HAL</span></div>
<div class="line">    HAL&amp; hal = touchgfx_generic_init&lt;MCUComponentClassName&gt;(dma, display, tc, DISPLAYWIDTH, DISPLAYHEIGHT, 0, 0); </div>
<div class="line">    hal.setFrameBufferStartAddress((uint16_t*)SDRAM_BASE_ADDR);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The DISPLAYWIDTH and DISPLAYHEIGHT arguments to touchgfx_generic_init must match the native resolution of the display.</dd></dl>
<p>Now we need to initialize hardware and the framework by calling these two functions from somewhere appropriate. Creating an OS task for the GUI and starting the scheduler will complete our basic system with no touch support and no DMA transfers. It could look like the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/HAL.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/BoardConfiguration.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The OS-specific GUI task should execute this function. </span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> GUITask(<span class="keywordtype">void</span>* params)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classtouchgfx_1_1_h_a_l_a9851dbb1edc99dbbe6ee5b876f79b40f.html#a9851dbb1edc99dbbe6ee5b876f79b40f">touchgfx::HAL::getInstance</a>()-&gt;<a class="code" href="classtouchgfx_1_1_h_a_l_a8314deacb6e9d3bdd50e3b89eb09cbd6.html#a8314deacb6e9d3bdd50e3b89eb09cbd6">taskEntry</a>(); <span class="comment">/*Starts processing events. Never returns.*/</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespacetouchgfx_acf938165e604a675fe09218a1b3cfb5f.html#acf938165e604a675fe09218a1b3cfb5f">hw_init</a>();</div>
<div class="line">  <a class="code" href="namespacetouchgfx_ae6e21dbb033844e61723026bf9b9a4ad.html#ae6e21dbb033844e61723026bf9b9a4ad">touchgfx_init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create OS GUI task.</span></div>
<div class="line">  <span class="comment">// Start scheduler.</span></div>
<div class="line">  <span class="comment">// Example for FreeRTOS:</span></div>
<div class="line">  xTaskCreate( GUITask, (<span class="keywordtype">signed</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;GUITask&quot;</span>,</div>
<div class="line">               configGUI_TASK_STK_SIZE,</div>
<div class="line">               NULL,</div>
<div class="line">               configGUI_TASK_PRIORITY,</div>
<div class="line">               NULL);</div>
<div class="line"></div>
<div class="line">  vTaskStartScheduler();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span>(;;);</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>At this point you should now have a basic port of TouchGFX, capable of executing your test application.</p>
<h1><a class="anchor" id="sect_port_extflash"></a>
Placing Graphics Data in External Flash</h1>
<p>Up until this point, the generated code for any graphics data/bitmaps (which is essentially just const arrays) have been located in the internal flash of the MCU along with the code and other const data. However, since bitmaps take up a substantial amount of space, you will almost always need to place bitmap data in the external flash instead. As a prerequisite from <a class="el" href="page_porting.html#sect_bbu">Board Bring-up</a>, there should already be read access to the external flash chip at runtime. To get started on this task, modify your test application to use an <a class="el" href="classtouchgfx_1_1_image.html">touchgfx::Image</a> widget, add a .bmp or .png image to your assets folder and build the simulator in order to generate the image data. Note that your Image widget must be configured to use the new bitmap. Verify that the simulator correctly displays your Image widget.</p>
<h2><a class="anchor" id="sect_port_linker"></a>
Linker Script</h2>
<p>The const arrays located in the autogenerated .cpp files under generated/images image data are annotated with a section attribute for easy placement in external flash. Simply amend the linker script for your target compiler to place "section ExtFlashSection" in the external flash memory area. Consult the MCU manual to determine the address space of this memory region. Note that the linker scripts used by the example applications for the supported evaluation boards already do this for IAR, Keil and GCC cross-compilers, so look there for inspiration (or reuse).</p>
<h2><a class="anchor" id="sect_port_flashloader"></a>
Flash Loader</h2>
<p>You are going to need a mechanism for programming the external flash with the contents of the ExtFlashSection of the produced binary image. This may or may not be easy depending on your particular toolchain and MCU/flash combination. IAR Embedded Workbench has a flash loader plugin mechanism which allows you to write a custom flash loader for the appropriate MCU and flash. IAR will, when configured to use such a flash loader, automatically invoke the appropriate flash loader a specified memory address range when deploying code (e.g. the built-in loader for internal flash, and a custom loader for the external flash). If your hardware matches one of the TouchGFX evaluation platforms, you can reuse the flash loader from there. The same overall mechanism applies to the Keil compiler, which also provides a collection of flash loader algorithms and the ability to create custom loaders. If compiling with GCC there are several tools available, both generic and platform specific. See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target">Target Hardware</a> for examples.</p>
<h2><a class="anchor" id="sect_port_sepproj"></a>
Separate Projects for Internal and External Flash</h2>
<p>Normally our projects are configured to include all code files, including generated data for the external flash, in a single project compiled as a single binary. There are, however, a few occasions where it makes sense to separate the code that goes into the external flash in a standalone project. For example the external flash loader used might require the binary to contain only external flash data, or the amount of external flash data is so large that you do not want to incur the delay of flashing it every time code in the internal flash changes. If deciding to split the project, please note the following. The autogenerated file BitmapDatabase.cpp must be placed in the internal flash project. It contains a table of addresses for the graphics data (i.e. external flash addresses). In order to successfully link the internal flash project in this case, the <em>external</em> flash project must be configured to emit a symbol file, listing the addresses of the symbols placed in external flash. This symbol file must then be included in the internal flash project, such that the linker is able to resolve the physical address of the symbols mentioned in the BitmapDatabase table.</p>
<p>At this point you should be able to deploy any application (including the examples and demos), since graphics data is now stored in the external flash. However with no touch input, its usefulness is somewhat limited.</p>
<h1><a class="anchor" id="sect_port_touch"></a>
Touch Driver</h1>
<p>Adding a touch driver is done by replacing the <a class="el" href="classtouchgfx_1_1_no_touch_controller.html">touchgfx::NoTouchController</a> we declared in our <a class="el" href="page_porting.html#sect_basic_boardconfig">BoardConfiguration</a> with another object deriving from the base class <a class="el" href="classtouchgfx_1_1_touch_controller.html">touchgfx::TouchController</a> that is capable of interfacing with the concrete touch controller mounted on the display. This object needs to provide implementation for two functions: <a class="el" href="classtouchgfx_1_1_touch_controller_a3d26ddb3e5608cbc4d20a481a97cc498.html#a3d26ddb3e5608cbc4d20a481a97cc498">init</a> which is called automatically during initialization, and <a class="el" href="classtouchgfx_1_1_touch_controller_a48b5d61f60d43680bda39a3a7c000006.html#a48b5d61f60d43680bda39a3a7c000006">sampleTouch</a>. The latter will be called once for every frame (i.e. once per VSYNC).</p>
<p>The <code>include/platform/driver/touch/ST1232TouchController.hpp</code> that comes with TouchGFX can be used for most of the Sitronix ST123x series of touch controllers, which are quite common. This driver requires an I<sup>2</sup>C implementation for the target microcontroller in order to work.</p>
<dl class="section note"><dt>Note</dt><dd>If polling the touch controller is MCU intensive, it might be a good idea to have sampleTouch only actually performing a sample once every other (or every third) frame. This would normally still be frequent enough for obtaining a responsive UI while reducing MCU load. This can be done through the <a class="el" href="classtouchgfx_1_1_h_a_l_a61b9ba64014639fbc554a8ea5b0eb3c7.html#a61b9ba64014639fbc554a8ea5b0eb3c7">HAL::setTouchSampleRate</a> function.</dd></dl>
<h2><a class="anchor" id="sect_touch_coords"></a>
Coordinate Transformations</h2>
<p>The default behaviour of TouchGFX is that no coordinate transformations take place. That means that the coordinates you report as out parameters in the <a class="el" href="classtouchgfx_1_1_touch_controller_a48b5d61f60d43680bda39a3a7c000006.html#a48b5d61f60d43680bda39a3a7c000006">touchgfx::TouchController::sampleTouch</a> function will be propagated to the widgets of your screen unmodified. If your display has a touch controller IC, which is the case for all capacitive touch displays and some resistive touch displays, the coordinates reported by the touch IC will most likely already be correct coordinates within the pixel dimensions of the display, and these can therefore be reported unmodified by sampleTouch. However, if your display is a 4-wire resistive touch where the MCU performs A/D conversions in order to read coordinate values, you will need a way to transform the (usually 12-bit) ADC values to pixel coordinates. In order to help with this scenario, TouchGFX provides a TouchCalibration matrix, which can translate ADC values to pixel coordinates. In order to use this feature, you must initialize the calibration matrix with a set of three reference x,y coordinates in screen space, and a corresponding set of ADC values for these three coordinates. The following is an example of such an initialization:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/transformations/TouchCalibration.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span>  <a class="code" href="structtouchgfx_1_1_point.html">Point</a>  lcdCalibPoints[3] =  <span class="comment">/* Display size is 800x480 */</span></div>
<div class="line">{</div>
<div class="line">  {  80,  48 }, <span class="comment">/* 10%, 10% */</span></div>
<div class="line">  { 720, 240 }, <span class="comment">/* 90%, 50% */</span></div>
<div class="line">  { 400, 432 }, <span class="comment">/* 50%, 90% */</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//calibration ADC 12 bit values</span></div>
<div class="line"><span class="keyword">static</span>  <a class="code" href="structtouchgfx_1_1_point.html">Point</a>  touchCalibPoints[3] =</div>
<div class="line">{</div>
<div class="line">  { 581, 3128 },  <span class="comment">/* ADC values read when clicking in 80,48 */</span></div>
<div class="line">  { 3475, 2025 }, <span class="comment">/* ADC values read when clicking in 720,240 */</span></div>
<div class="line">  { 2001, 978 },  <span class="comment">/* ADC values read when clicking in 400,432 */</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="classtouchgfx_1_1_touch_calibration_abfada6f5dd981efffaae0208e5b1c981.html#abfada6f5dd981efffaae0208e5b1c981">TouchCalibration::setCalibrationMatrix</a>(lcdCalibPoints, touchCalibPoints);</div>
<div class="line"><span class="comment">// From this point on, sampleTouch can just report raw ADC values, and TouchGFX will automatically convert</span></div>
<div class="line"><span class="comment">// these to screen space coordinates based on the three setpoints.</span></div>
</div><!-- fragment --><p>If you wish to apply a more advanced coordinate translation you can of course just do that within your <a class="el" href="classtouchgfx_1_1_touch_controller.html">driver</a> and disregard the touch calibration functionality.</p>
<h1><a class="anchor" id="sect_comp_dma"></a>
DMA Component</h1>
<p>The last task in the porting effort is to make use of DMA to transfer graphics data from external flash (or external RAM cache) to the frame buffer.</p>
<dl class="section note"><dt>Note</dt><dd>If your UI is 1 bit per pixel (monochrome), do not bother implementing a DMA component, as it is not supported by the framework in 1BPP mode. Use NoDMA instead.</dd></dl>
<p>Adding DMA support will <em>substantially</em> reduce the MCU load imposed by TouchGFX on your target platform. It is therefore highly recommended to support at least BLIT_OP_COPY (basic drawing of opaque bitmaps). In TouchGFX, a DMA component acts as an interface to the DMA peripheral of the microcontroller, and is as such usually tightly coupled with the MCU component. It is responsible for initiating DMA transfers of graphics data, and notifying TouchGFX when these transfers are complete. In terms of code, a DMA component is specifically a subclass of the <a class="el" href="classtouchgfx_1_1_d_m_a___interface.html">touchgfx::DMA_Interface</a> class.</p>
<p>It is already present for the following:</p><ul>
<li><b>NXP LPC43xx series</b> (<code>include/platform/hal/nxp/mcu/LPC43xx/NXP43XXDMA.hpp</code>)</li>
<li><b>NXP LPC17xx series</b> (<code>include/platform/hal/nxp/mcu/LPC17xx/NXP1788DMA.hpp</code>)</li>
<li><b>NXP LPC18xx series</b> (<code>include/platform/hal/nxp/mcu/LPC18xx/NXP18xxDMA.hpp</code>)</li>
<li><b>ST STM32F429/STM32F439</b> (<code>include/platform/hal/ST/mcu/stm32f4x9/STM32F4DMA.hpp</code>)</li>
<li><b>Freescale K70</b> (<code>include/platform/hal/Freescale/mcu/MK70F12/FreescaleK70DMA.hpp</code>)</li>
</ul>
<p>When creating a DMA component, the following pure virtual functions need to be implemented. They are explained in greater detail in the following table. </p><table class="doxtable">
<tr>
<th>Function </th><th>Purpose  </th></tr>
<tr>
<td>getBlitCaps() </td><td>This function returns which blitting capabilities are supported by this DMA component.  </td></tr>
<tr>
<td>setupDataCopy() </td><td>Initiates a DMA transfer. Used for all copy-based blit operations (bitmap transfers), where source address is incremented for each pixel.<br />
 This function is called when encountering the following blit operations:<ul>
<li>BLIT_OP_COPY</li>
<li>BLIT_OP_COPY_WITH_ALPHA</li>
<li>BLIT_OP_COPY_ARGB8888</li>
<li>BLIT_OP_COPY_ARGB8888_WITH_ALPHA</li>
<li>BLIT_OP_COPY_A4</li>
<li>BLIT_OP_COPY_A8   </li>
</ul>
</td></tr>
<tr>
<td>setupDataFill() </td><td>Initiates a DMA transfer. Used for all fill-based blit operations (i.e. <a class="el" href="classtouchgfx_1_1_box.html">touchgfx::Box</a>), where a single color is copied to all pixels (i.e. no source increment).<br />
 This function is called when encountering the following blit operations:<ul>
<li>BLIT_OP_FILL</li>
<li>BLIT_OP_FILL_WITH_ALPHA   </li>
</ul>
</td></tr>
<tr>
<td>signalDMAInterrupt() </td><td>This function, which is called by the DMA ISR, must determine whether the interrupt was caused by a DMA transfer being completed. If so, it must call executeCompleted() in the base class.  </td></tr>
</table>
<p>During the TouchGFX rendering pass, the framework will query the getBlitCaps function to determine whether a given blitting operation can be delegated to the hardware (the DMA object). If that is the case, the <a class="el" href="classtouchgfx_1_1_d_m_a___interface_a77baa864b8064fa3076a9b5eafab7292.html#a77baa864b8064fa3076a9b5eafab7292">touchgfx::DMA_Interface::setupDataCopy</a> or <a class="el" href="classtouchgfx_1_1_d_m_a___interface_ac4b88d8ee4355a278d1b11562e7e90e8.html#ac4b88d8ee4355a278d1b11562e7e90e8">touchgfx::DMA_Interface::setupDataFill</a> will be called automatically when appropriate. Blitting operations that are not supported by the DMA component will be rendered using software fallback instead. Therefore, the DMA component must be able to properly handle the blitting operations returned by the getBlitCaps function.</p>
<p>As mentioned, the most important blit operation to support is BLIT_OP_COPY, which is a basic data copy from bitmap data to the frame buffer. It is used for drawing bitmaps that are completely solid (no alpha blending). In most cases this will cover the majority of the pixel transfers for a given application. Most, if not all DMA engines on 32-bit MCUs will be able to support this operation. The BLIT_OP_FILL operation is used for drawing solid rectangles of a specific color (the <a class="el" href="classtouchgfx_1_1_box.html">touchgfx::Box</a> widget). It too should be implementable on any hardware, but this widget is not normally used very often, so it is of less importance. The remaining blit operations require advanced DMA hardware, capable of applying alpha-blending or doing color format conversions on the fly.</p>
<p>There are two important things to note when implementing a DMA subclass:</p><ol type="1">
<li>The DMA must support <em>two-dimensional</em> transfers</li>
<li>The transfer must be as fast as possible</li>
</ol>
<h2><a class="anchor" id="sect_port_2d"></a>
Two-dimensional Transfers</h2>
<p>Because of the occlusion culling mechanism of TouchGFX, the actual transfer of bitmap data to the frame buffer will be split in many partial transfers. This has the implication that most DMA transfers will be two-dimensional as opposed to a simple linear transfer. If only a portion of a bitmap is to be transferred, then for each line an offset (address increment) has to be applied for both the source and destination address, and those two offsets will have a different value since the width of the display is most likely different than the width of the bitmap. While some DMA peripherals support this type of transfer natively by providing registers for both source and destination address increment, it is not too common. If this is not supported, the functionality can usually be achieved by doing a scatter-gather transfer instead, where a linked list is constructed in RAM, with an element for each line.</p>
<h2><a class="anchor" id="sect_port_dmaopt"></a>
Optimizing DMA Transfers</h2>
<p>The bottleneck of the system in terms of graphics performance is the transfer of pixels from external flash to the frame buffer. Therefore, the performance of the DMA transfers are of paramount importance, and it is usually a good investment to spend time on optimizing the performance of these transfers. Performing 32-bit transfers whenever possible is an easy optimization yielding a substantial improvement, instead of just transferring a single pixel (16 bits) at a time. Most DMAs support setting a transfer unit size of 32 bits. Of course this optimization is only possible to apply for transfers that are actually 32-bit aligned, which usually means that the following must be true: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> use32Bit = (blitOp.nSteps%2)==0 &amp;&amp;              <span class="comment">// Pixels pr line is even</span></div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)blitOp.pSrc&amp;3)==0 &amp;&amp; <span class="comment">// src-address is 32bit-aligned</span></div>
<div class="line">                ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)blitOp.pDst&amp;3)==0 &amp;&amp; <span class="comment">// dst-address is 32bit-aligned</span></div>
<div class="line">                (blitOp.srcLoopStride%2)==0 &amp;&amp;       <span class="comment">// src-stride is even</span></div>
<div class="line">                (blitOp.dstLoopStride%2)==0;         <span class="comment">// dst-stride is even</span></div>
</div><!-- fragment --><p> This optimization is the basis for the recommendation to place bitmaps on even coordinates and give them an even width.</p>
<h2><a class="anchor" id="sect_port_dmaex"></a>
Example Transfer</h2>
<p>The framework itself will perform the address calculations necessary for both source and destination addresses before calling setupDataCopy, so the fields of the BlitOp struct passed as arguments to this function just need to be mapped to the appropriate DMA peripheral registers of the MCU. In this example, the blit op is a request to copy a partial area of a bitmap to a frame buffer with a width of 480 pixels: </p><div class="image">
<img src="dma_partial.png" alt="dma_partial.png"/>
<div class="caption">
Example bitmap 160x100 pixels, with a subsection of 75x80 pixels that needs to be transferred by DMA</div></div>
 <br />
 The BlitOp struct passed to setupDataCopy in this example will contain the following values: </p><pre class="fragment">  pSrc: Address of first pixel to be transferred (commonly external flash)
  pDst: Destination address of first pixel in frame buffer (commonly external RAM)
  nSteps: 75 (pixels in a line)
  nLoops: 80 (number of lines)
  srcLoopStride: 160 (width of bitmap)
  dstLoopStride: 480 (width of frame buffer)
  operation: BLIT_OP_COPY (simple 2D transfer from source to destination)
  color: Do not care (N/A for BLIT_OP_COPY)
  alpha: 255 (Always completely opaque for BLIT_OP_COPY)
</pre><p>The TouchGFX framework must be notified when a transfer is complete, so the frame buffer semaphore can be released. To achieve this, the DMA transfer should be configured to generate an interrupt upon transfer completion. </p><dl class="section note"><dt>Note</dt><dd>If using scatter-gather, make sure an interrupt is only generated upon completion of the last line</dd></dl>
<p>The interrupt service routine which fires upon completion is discussed in <a class="el" href="page_porting.html#sect_port_interrupts">Interrupt Configuration</a>.</p>
<h2><a class="anchor" id="sect_port_interrupts"></a>
Interrupt Configuration</h2>
<p>TouchGFX does not begin processing the next element of the DMA queue until it has been informed of the completion of the previous DMA transfer. Therefore, a DMA interrupt handler needs to be installed, which should look something like the following: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">__irq <span class="keywordtype">void</span> DMA_IRQHandler( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="classtouchgfx_1_1_h_a_l_a9851dbb1edc99dbbe6ee5b876f79b40f.html#a9851dbb1edc99dbbe6ee5b876f79b40f">touchgfx::HAL::getInstance</a>()-&gt;<a class="code" href="classtouchgfx_1_1_h_a_l_a5e6cf4d44af298d5d01023f51ee4a182.html#a5e6cf4d44af298d5d01023f51ee4a182">signalDMAInterrupt</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The notification to TouchGFX goes through the HAL object since it is globally accessible. HAL will simply call signalDMAInterrupt on the generic DMA object, which is a pure virtual function in the base class that needs to implemented for the specific MCU used. This implementation should determine whether the DMA interrupt means that a transfer has been completed and in that case call <a class="el" href="classtouchgfx_1_1_d_m_a___interface_a95c4209c9ac3116ca5e7a22fae4d58df.html#a95c4209c9ac3116ca5e7a22fae4d58df">touchgfx::DMA_Interface::executeCompleted</a> : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyDMAComponent::signalDMAInterrupt()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (int_src == myLastTransfer)<span class="comment">//Determine whether interrupt was caused by our last transfer being complete.</span></div>
<div class="line">  {</div>
<div class="line">    executeCompleted();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The execution path of both the DMA and TFT interrupt will end up in semaphore manipulation functions of <a class="el" href="classtouchgfx_1_1_o_s_wrappers.html">touchgfx::OSWrappers</a>. These are non-blocking of course, but your operating system might require that the interrupt priorities from these two sources are configured to be lower priority than those used by the operating system itself.</dd></dl>
<h1><a class="anchor" id="sect_port_gpio"></a>
Adding a GPIO implementation</h1>
<p>The TouchGFX framework expects an implementation of the <a class="el" href="classtouchgfx_1_1_g_p_i_o.html">touchgfx::GPIO</a> class to be present as part of the hardware abstraction layer. The purpose of this class is to provide facilities for instrumentation of the timing and performance of TouchGFX. It is a simple class, capable of toggling four GPIO pins of your own choice. </p><dl class="section note"><dt>Note</dt><dd>The class is mandatory, but the functions can be left empty / un-implemented.</dd></dl>
<p>The GPIO set/clear/toggle functions serve to provide timing output for the following four signals: </p><table class="doxtable">
<tr>
<th>Signal </th><th>Purpose </th><th>Note  </th></tr>
<tr>
<td>VSYNC_FREQ </td><td>Readout for the VSYNC signal. </td><td>Platform-dependent. Your porting should include calls to GPIO set/clear for this signal in the LCD interrupt handler.  </td></tr>
<tr>
<td>RENDER_TIME </td><td>Goes high when TouchGFX starts processing a frame, and low on completion </td><td>This signal is toggled automatically by the framework  </td></tr>
<tr>
<td>FRAME_RATE </td><td>Toggles whenever a frame buffer swap occurs </td><td>This signal is toggled automatically by the framework  </td></tr>
<tr>
<td>MCU_ACTIVE </td><td>Toggles when the OS Idle task is entered/exited </td><td>OS-dependent. Already implemented for FreeRTOS in the corresponding OSWrappers.cpp file. For other OSes must be implemented manually  </td></tr>
</table>
<p>If you implement the GPIO class such that four pins of your choice are toggled, you can attach an oscilloscope and get readouts similar to those presented in the <a class="el" href="page_advanced.html#sect_adv_timing_framerate">Frame Rate</a> section of the <a class="el" href="page_advanced.html">Advanced</a> chapter. This is normally very useful for optimizing performance.</p>
<p>See also <a class="el" href="page_advanced.html#sect_advanced_perfmeas">Performance Measurement</a></p>
<h1><a class="anchor" id="sect_porting_altflash"></a>
Non-memory mapped external flash / Supporting bitmap caching</h1>
<p>This chapter deals with the special case of having an external flash which cannot be read by simply dereferencing a pointer to somewhere in the external flash memory region. Instead, reading the flash contents must go through a device-specific driver function. This is generally the case with all serial flashes or flashes which require bad block handling (e.g. NAND flashes). As an exception some NXP microcontrollers provide a memory-mapped interface for serial flashes (SPIFI), in which case a serial NOR flash can be used straightforwardly and this chapter can be disregarded.</p>
<p>For performance reasons, TouchGFX expects all graphics data stored in external flash to be directly accessible, without going through a driver layer. Therefore TouchGFX cannot render directly from a non-memory mapped flash. Instead we provide a simple mechanism for caching all graphics data in external RAM during power-up. The rendering mechanism will then read from there instead of the external flash. This, of course, requires that the external RAM is large enough to hold not only frame buffers but also a copy of all graphics data.</p>
<p>The details of using bitmap caching in an application is described in the <a class="el" href="page_advanced.html#sect_adv_bitmap_caching">Bitmap Caching</a> section of the <a class="el" href="page_advanced.html">Advanced</a> page. But in order for bitmap caching to work properly on the specific platform you are porting to, you need to supply a driver for copying a block of data from the flash to the cache and to configure TouchGFX with a memory region to use for caching. The former is done by implementing the <a class="el" href="classtouchgfx_1_1_h_a_l_a9d4e228a3d60259b4b985bed0b2a4a53.html#a9d4e228a3d60259b4b985bed0b2a4a53">touchgfx::HAL::blockCopy</a> function in your <a class="el" href="page_porting.html#sect_basic_mcu">MCU Component</a>. The function simply needs to be able to copy a number of bytes from an address in the flash to the caching area (typically external RAM). <a class="el" href="classtouchgfx_1_1_h_a_l_a9d4e228a3d60259b4b985bed0b2a4a53.html#a9d4e228a3d60259b4b985bed0b2a4a53">touchgfx::HAL::blockCopy</a> will be called automatically a number of times (one for each bitmap) when caching bitmaps.</p>
<p>Recall from <a class="el" href="page_porting.html#sect_port_linker">Linker Script</a> that bitmap data is placed in a section called ExtFlashSection. If you want to e.g. place bitmaps on an SD card and use bitmap caching you can do the following:</p><ol type="1">
<li>Change linker script to place ExtFlashSection at some unused area, e.g. 0x24000000.</li>
<li>Implement HAL::blockCopy in your subclass like this: <div class="fragment"><div class="line"><span class="comment">// This function is called whenever a bitmap is cached. Must copy a number of bytes from the (non-memory-mapped) source to the cache.</span></div>
<div class="line"><span class="keywordtype">bool</span> MyHAL::blockCopy(<span class="keywordtype">void</span>* RESTRICT dest, <span class="keyword">const</span> <span class="keywordtype">void</span>* RESTRICT src, uint32_t numBytes)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span>* dataOffset = src – 0x24000000;</div>
<div class="line">    sdcard_read(dest, dataOffset, numBytes);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<p>The example function above assumes that there exists a driver function called sdcard_read() which is capable of reading from the SD card. You need to supply the correct function for copying data of course.</p>
<dl class="section note"><dt>Note</dt><dd>There is a default implementation of blockCopy in the generic HAL class, which will essentially perform a memcpy() from src to dest. If your bitmap data (src) is in fact located in a memory-mapped region, there is no need to provide a blockCopy specialization in your HAL subclass. Likewise, if bitmap caching is not used in your application(s), there is no need to provide a specialization either.</dd></dl>
<h2><a class="anchor" id="sect_porting_altflash_config"></a>
Configuring the Cache</h2>
<p>In order to make use of bitmap caching, TouchGFX must be informed of the memory area to use for caching as well as the size of that memory area. This is done through the <a class="el" href="namespacetouchgfx_a3fb902a151e120d1bca9ac2ba3b7bc56.html#a3fb902a151e120d1bca9ac2ba3b7bc56">touchgfx::touchgfx_generic_init</a> function (which is called from your <a class="el" href="page_porting.html#sect_basic_boardconfig">BoardConfiguration</a> file) where the last two arguments configures the bitmap cache. The first of these is simply a pointer to the beginning of the memory region where the bitmap cache is to be located. This will usually be external RAM. The last argument configures the size of the cache area, and will impact how many bitmaps it is possible to keep in the cache simultaneously. The required size depends somewhat on data alignment on your platform as well as the bitmap format used. As a general rule of thumb, the required size of your bitmap cache will be </p><div class="fragment"><div class="line">CacheSize = TOTAL_NUMBER_OF_BITMAPS_IN_APPLICATION * <span class="keyword">sizeof</span>(uint8_t*) + SIZE_IN_BYTES_OF_CACHED_BITMAPS</div>
</div><!-- fragment --><p> Where the size of each cached bitmap will be approximately </p><pre class="fragment">width * height * 2 for RGB565 images with no alpha channel
width * height * 3 for RGB565 images with alpha channel
width * height * 4 for ARGB8888 images
</pre><p>When caching a bitmap, the return value will indicate if the operation failed due to lack of memory. If you are certain that there is enough memory available, you need not bother with calculating the size parameter and can instead just pass 0xFFFFFFFF as size argument. This is safe to do since the caching mechanism will not access the remaining memory chunk outside the needed size.</p>
<h1><a class="anchor" id="sect_porting_optimize"></a>
Optimization</h1>
<p>In many cases, some tweaking will substantially increase performance. It is therefore strongly recommended to follow the hints in this chapter.</p>
<h2><a class="anchor" id="sect_porting_optimize_lock"></a>
Optimizing DMA During TFT Controller Access</h2>
<p>The single most important performance optimization to perform is to allow DMA transfers to take place while the TFT controller is updating the display. This is done by calling the following function in your TouchGFX initialization code: </p><div class="fragment"><div class="line">HAL::getInstance()-&gt;lockDMAToFrontPorch(<span class="keyword">false</span>); <span class="comment">//DMA is now no longer tied to the TFT controller.</span></div>
</div><!-- fragment --><p>When doing this, the DMA will no longer be locked to the TFT controller and thereby allowing DMA transfers to begin immediately, instead of having to wait until the front porch is entered (TFT controller exits active area). In most cases this will decrease the rendering time by around 25%. This optimization requires that the MCU of your platform is able to correctly perform arbiting of simulataneous RAM access by DMA and TFT. If this is not the case you will immediately see rendering errors on the display when enabling this optimization, in which case it cannot be used on that platform. The board configurations distributed with TouchGFX are configured to enable this optimization on the platforms where it is known to be supported. If you use a custom board configuration, or a board configuration from TouchGFX 4.1.1 or earlier, you must manually enable this optimization.</p>
<p>If using single buffering, this optimization can only be applied in cases where you do not use a regular TFT controller. It is applicable, for instance, when using 8080 or DSI mode displays in single buffering configuration.</p>
<dl class="section note"><dt>Note</dt><dd>This optimization is scheduled to be default enabled in TouchGFX 5.0.</dd></dl>
<h2><a class="anchor" id="sect_porting_tweaktft"></a>
Optimizing VSYNC Timing</h2>
<p>The chapter <a class="el" href="page_advanced.html#sect_adv_timing">Timing and TFT Controller Integration</a> explains in detail how the TFT controller timing relates to the rendering of frames. As mentioned earlier in the porting guide, having a VSYNC interval of around 16-20 milliseconds is generally a good value, but if you are seeing performance problems on particularly complex screens in your application, it is most likely a good idea to tweak the VSYNC interval.</p>
<h2><a class="anchor" id="sect_porting_optsampletouch"></a>
Touch Sample Method and Frequency</h2>
<p>If your application is very dependent on a low MCU load at all times, it can be a good idea to reduce the frequency with which the Touch Controller is being sampled, through the function <a class="el" href="classtouchgfx_1_1_h_a_l_a61b9ba64014639fbc554a8ea5b0eb3c7.html#a61b9ba64014639fbc554a8ea5b0eb3c7">HAL::setTouchSampleRate</a>. In many cases it will be sufficient to sample touch approximately every three ticks instead of every tick or maybe even less. Most, if not all, capacitive touch controllers have an output pin to signal that touch data if available. By reading this pin, unnecessary polling of the touch controller can be avoided.</p>
<h1><a class="anchor" id="sect_porting_notft"></a>
MCUs without TFT controller</h1>
<p>TouchGFX can be configured to run on MCUs with no built-in TFT controller. In that case, one would normally attach a display though SPI or similar, and use some kind of protocol to set {x,y} positions and transfer pixel data over the serial connection. In this scenario, however, it is still necessary to use frame buffer(s). TouchGFX does <em>not</em> support rendering directly to a TFT display. After rendering to the frame buffer is complete, you can through a hook function transmit the changes to the display.</p>
<p>As explained in <a class="el" href="page_advanced.html#sect_adv_timing">Timing and TFT Controller Integration</a>, TouchGFX relies on a TFT controller interrupt signal to periodically activate the GUI task. In the absence of a TFT controller, a hardware timer or similar must be configured to periodically wake the GUI task instead: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> HW_Timer_IRQHandler()</div>
<div class="line">{</div>
<div class="line">  OSWrappers::signalVSync(); </div>
<div class="line">}</div>
</div><!-- fragment --><p>The tick frequency of this timer should be around 50Hz. <br />
<br />
In order to transfer the contents of the frame buffer to the display, override the function <a class="el" href="classtouchgfx_1_1_h_a_l_aadf72566150a92da9c986c0bdbd43eca.html#aadf72566150a92da9c986c0bdbd43eca">HAL::flushFrameBuffer(const Rect&amp;)</a>. This function is called at the end of each frame, with the parameter Rect describing the area of the frame buffer that was changed. This area must then be transferred to the display using the appropriate communication protocol.</p>
<p>When not using a TFT controller, you should enable the optimization mentioned in <a class="el" href="page_porting.html#sect_porting_optimize_lock">Optimizing DMA During TFT Controller Access</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
