<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TouchGFX: Build and Execute</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="touchgfx.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="touchgfxlogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TouchGFX
   &#160;<span id="projectnumber">v4.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_build_and_execute.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Build and Execute </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes how you build and run your code on both the PC Simulator and on target hardware. <a class="el" href="page_build_and_execute.html#sect_build_and_execute_quickstart">Quickstart</a> lets you dive right in, while the remaining sections go into more detail about building for the PC simulator and target hardware.</p>
<h1><a class="anchor" id="sect_build_and_execute_quickstart"></a>
Quickstart</h1>
<p>If you are anxious to dive right in without further ado and experience TouchGFX in action, navigate to <code>app/example/button_example</code> from your TouchGFX installation folder and execute the two commands below. This will build and run the button example application in the TouchGFX simulator using <em>gcc</em>. A working TouchGFX development environment (See <a class="el" href="page_development_environment.html">Development Environment</a>) is a pre-requisite.</p>
<pre class="fragment">$ make -f simulator/gcc/Makefile
$ ./build/bin/simulator.exe
</pre><p><br />
 You can also build and run the example code in Visual Studio 2010/2012/2013. To do this, build the solution file located in <code>app/example/button_example/simulator/msvs/</code>. Other pre-made applications can be found in the <code>app/</code> directory. See <a class="el" href="page_examples.html">Examples</a> and <a class="el" href="page_demos.html">Demos</a>. If you are using Visual Studio 2010 you must update it with Service Pack 1 (SP1) for Visual Studio 2010. It is available through Windows Update or directly from <a href="http://www.microsoft.com/en-us/download/details.aspx?id=23691">Microsoft's webpage</a></p>
<p>Deploying an application to a hardware platform is discussed in detail in <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target">Target Hardware</a> which covers downloading to all the supported evaluation boards (see <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_files_supported_hardware">Supported Hardware</a>).</p>
<h1><a class="anchor" id="sect_build_and_execute_make"></a>
Make</h1>
<p>TouchGFX makes heavy use of Make to convert application assets to code, build simulator applications and applications for target hardware. The Makefiles of TouchGFX provide four simple commands:</p>
<ol type="1">
<li><code>clean</code> - Cleans application build and generated assets.</li>
<li><code>all</code> - Generates assets and builds application (Default target)</li>
<li><code>assets</code> - Generates assets</li>
<li><code>flash</code> - Flash application to target hardware (Using ST-Link CLI)</li>
</ol>
<p>Here's a few useful make commands:</p>
<pre class="fragment"># Clean and generate only assets
$ make -f simulator/gcc/Makefile clean assets
</pre> <pre class="fragment"># Clean, generate assets and build simulator application
$ make -f simulator/gcc/Makefile clean all
</pre> <pre class="fragment"># Clean, generate assets and build application for specific target
$ make -f target/ST/STM324x9I-CUBE/gcc/Makefile clean all
</pre> <pre class="fragment"># flash an application with ST-Link
$ make -f target/ST/STM32429I-EVAL1/gcc/Makefile flash
</pre><p> <br />
The <code>flash</code> command can only be used on a windows platform and if ST-Link is properly installed.</p>
<div class="image">
<img src="st-link-cli.png" alt="st-link-cli.png"/>
<div class="caption">
Flash application using Make</div></div>
<br />
 The flash command might fail with the following error, due to the external flash being mounted as an USB device in windows.</p>
<div class="image">
<img src="st-link-comm-error.png" alt="st-link-comm-error.png"/>
<div class="caption">
ST-Link CLI communication error</div></div>
<br />
 Disabling the USB device driver for your particular board in Windows Device Manager should fix the issue:</p>
<div class="image">
<img src="MBED_disable.png" alt="MBED_disable.png"/>
<div class="caption">
Disable MBED microcontroller</div></div>
<br />
 </p>
<h1><a class="anchor" id="sect_build_and_execute_simulator"></a>
PC Simulator</h1>
<p>TouchGFX comes with a PC-based simulator that can run on both Windows and Linux platforms. Please note that only 64-bit Linux is supported. TouchGFX is platform independent, so when running the simulator, all code being executed, except for the code in specific HAL implementations, is exactly the same as when running on a target platform making application development seamless from simulator to target hardware.</p>
<p>The simulator provides an easy way of getting started without having a target hardware platform available. In addition, it provides a build-chain which automatically generates the source code representation of images, fonts, texts and translations to be included in the application. While using the simulator is optional, you will get the code generation of assets done automatically instead of manually having to execute the conversion tools, so we recommend keeping the simulator around.</p>
<p>Since the TouchGFX build utilize dependency-checking mechanism to examine the assets folders, adding a new image, modifying an image or changes to the text spreadsheet will automatically result in the appropriate source code being generated next time you compile.</p>
<p>When creating your own applications, as long as you base your file and directory structure on that of the template_application, you should easily be able to generate assets and compile everything by typing <code>make -f simulator/gcc/Makefile</code> in the application root directory or by using the Visual Studio solution located in <code>simulator/msvs</code>.</p>
<p><em>Note:</em> If you do not wish to use our toolchain for compiling your source code, you can use the command </p><pre class="fragment">$ make -f simulator/gcc/Makefile assets
</pre><p>to generate asset output and not compile anything. You could then use your favorite IDE to compile and link the sources.</p>
<h2><a class="anchor" id="sect_build_and_execute_simulator_MinGW"></a>
MinGW / GCC</h2>
<p>To build and run a TouchGFX application in the MinGW shell do the following (using the button_example as example).</p>
<p>Launch the development environment shell, navigate to the place where TouchGFX is located and cd into the <code>app/example/button_example</code> directory. To compile, simply type</p>
<pre class="fragment">$ make -f simulator/gcc/Makefile
</pre><p> <br />
This process will generate the assets used in the application, and produce a binary of the simulator placed in <code>build/bin</code>. To execute the simulator, type</p>
<pre class="fragment">$ ./build/bin/simulator.out
</pre><h2><a class="anchor" id="sect_build_and_execute_visual_studio"></a>
Visual Studio</h2>
<p>Visual Studio 2010/2012/2013 is an alternative to using make. All supplied applications (in <code>app/&lt;type&gt;/&lt;app_name&gt;/simulator/msvs/</code>) comes with a complete Visual Studio solution that is ready to compile and run.</p>
<p>Assets are automatically generated when compiling in Visual Studio.</p>
<p><em>Note:</em> If you are trying to compile a Visual Studio 2012 project in Visual Studio 2010 you will get a compile error stating that "Specified platform toolset (v110) is not installed or invalid". To fix this right-click on the project in the Soulution Explorer and select "properties". Select Configuration Properties/General. Here you can change the Platform Toolset from v110 to v100. Then rebuild.</p>
<p><em>Note:</em> Also note, that the supplied a Visual Studio project files are all distributed as Visual Studio 2010 projects. If you are using a newer version of Visual Studio, either choose to upgrade the project when you load it the first time (Visual Studio will tell you that "one or more projects use an earlier version of the Visual C++ compiler and libraries"), or select the project in the Solution Explorer and from the menu, select "PROJECT", "Update VC++ projects...". Remember to rebuild after updating the project.</p>
<h1><a class="anchor" id="keil_uvision_versions"></a>
Keil Compiler Cross-Version Compatibility</h1>
<p>Keil projects for Cortex-M7 based targets (STM32F746G-DISCO and STM32756G-EVAL) are based on Keil uVision 5. Project files based on the new .uvprojx format are not compatible with Keil uVision 4. When one, illegally, attempts to open an .uvprojx Keil 4, the following error occurs:</p>
<div class="image">
<img src="keil5withKeil4.png" alt="keil5withKeil4.png"/>
<div class="caption">
Opening a Keil 5 project with Keil 4</div></div>
<br />
 Opening a keil 4 project (.uvproj) with Keil 5 is allowed but produces the following prompt to migrate to the new format or to install legacy support.</p>
<div class="image">
<img src="keil4withKeil5.png" alt="keil4withKeil5.png"/>
<div class="caption">
Opening a Keil 4 project with Keil 5</div></div>
 <h1><a class="anchor" id="sect_build_and_execute_target"></a>
Target Hardware</h1>
<p>TouchGFX currently supports three compilers for microcontroller targets:</p>
<ol type="1">
<li>IAR C/C++ Compiler for ARM</li>
<li>Keil Compiler for ARM (uVision 4 and 5 IDE)</li>
<li>GNU GCC Compiler for ARM</li>
</ol>
<p>For a list of supported hardware and compilers see <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_files_supported_hardware">Supported Hardware</a>.</p>
<p>The section <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc">GCC Building applications with GNU GCC compiler for ARM</a> shows you how to build applications using GNU GCC compiler for ARM and also goes into detail about how to program each board. In general, for ST based boards, the ST-Link flashing utility is always used.</p>
<ol type="1">
<li>TouchGFX demo board 4.3" (NXP LPC4350, No internal flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_lpc4350">Programming TouchGFX demo board 4.3" LPC4350 when Compiling with GCC</a></li>
<li>TouchGFX demo board 4.3"/5.7"/7.0" (NXP LPC4353, Internal+External flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_lpc4353">Programming TouchGFX demo board 4.3"/7.0" LPC4353 when Compiling with GCC</a></li>
<li>STM32429I-EVAL1 4.3" (ST STM32F4, Internal+External flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a></li>
<li>STM324x9I-EVAL 5.7" (ST STM32F4, Internal+External flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a></li>
<li>STM32F429I-DISCO (ST STM32F4, No external flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a></li>
<li>STM32F746G-DISCO (ST STM32F7, Internal+External flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a></li>
<li>STM32756G-EVAL (ST STM32F7, Internal+External flash) - See <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a></li>
</ol>
<p>By inspecting the structure of the <code>target/</code> folder for any application, we may learn about which targets that application is intended to support. If an application was designed for a 4.3" display, any targets with 7.0" displays would typically not be represented here. The application <code>app/template/EmptyApplication</code> is an empty application shell that contains every target supported by TouchGFX. Each vendor folder contains supported target configuration from that vendor. Each target contains application project configurations for supported compilers. </p><pre class="fragment">+-- target
|   +-- EmbeddedArtists
|   |       +-- gcc 
|   |       \-- IAR
|   |       \-- Keil
|   +-- FDI
|   +-- Mjolner
|   \-- ST
</pre><h2><a class="anchor" id="sect_build_and_execute_target_supported_iar"></a>
Building and downloading applications with IAR</h2>
<p>Every IAR workspace file in the TouchGFX distribution incorporates a flash-loader configuration for the specific target it is designed for. For instance, if we navigate to the Button Example application at <em>app/example/button_example</em> we can open up an IAR target configuration for the STM32429I-EVAL1 board at <code>target/ST/STM32429I-EVAL1/IAR/application.eww</code> and prepare to download the <em>Button Example</em> application. To download the application simply attach a debugger of choice (must be supported by IAR) to the target hardware and configure the debugger in the projects configuration; In the image below we are using IAR's own i-jet debugger.</p>
<div class="image">
<img src="iar_debugger.png" alt="iar_debugger.png"/>
</div>
  <br />
 All TouchGFX libraries and applications have been built and tested using IAR Embedded Workbench for ARM version 6.60.1.5104 and compatibility beyond that point has not been thoroughly tested. IAR workspace files are compatible with version 7.20.</p>
<dl class="section note"><dt>Note</dt><dd><b>STM32756G-EVAL</b>: Currently, TouchGFX does not support an IAR flash loader for the <em>external</em> flash of the STM32F7 based EVAL boards. The IAR projects are currently configured to only program the internal flash and you should see an error during target programming related to a missing flashloader algorithm for any data starting at 0x90000000. To flash the external flash, open the application .hex binary produced by IAR (i.e. <code>/target/ST/STM32756G-EVAL/IAR/Debug/Exe/application</code>.hex) and flash using ST’s "ST-Link" flash utility. This procedure is described in <a class="el" href="page_build_and_execute.html#sect_build_and_execute_target_gcc_st">Programming ST Boards when Compiling with GCC</a>.</dd></dl>
<h2><a class="anchor" id="sect_build_and_execute_target_keil"></a>
Building and downloading applications with Keil uVision</h2>
<p>The TouchGFX distribution offers support for both Keil uVision4, with preconfigured settings for flashing both the internal and external flash regions. Like with IAR, you will find a uVision project (.uvproj file) in the target folder for a given application. Please note that not all boards have support for Keil at the moment. Please refer to <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_files_supported_hardware">Supported Hardware</a> for details on which boards support Keil out of the box. To deploy an example on an evaluation board, simply open the uVision project file, hit F7 to compile the code and press the "Load" button afterwards. You will then need to either start a debugging session from within uVision or simply power cycle the target to get the application running.</p>
<p>The Keil projects are preconfigured to use the J-Link debugger. This can be changed in project options, as shown below. But please note that in uVision, the flash programming algorithms for the target are tied to the chosen debugger, so if you change debugger, you need to also (re)configure the flash programming algorithms to match those used when J-link is selected. </p><div class="image">
<img src="keil-flash.png" alt="keil-flash.png"/>
<div class="caption">
Configuration of debuggger and flash algorithms in Keil uVision4</div></div>
<br />
The screenshots above are from a specific target (LPC4357DevKit). The exact flash algorithms used vary among boards, so the example above is just a guideline. All evaluation boards have the correct flash algorithms installed for the J-Link debugger, so examine that setting for correct flash algorithms for other debuggers.</p>
<h3><a class="anchor" id="sect_build_and_execute_target_keil_st"></a>
Downloading Applications for ST ST3249xI eval board (4.3" and 5.7" display) with Keil uVision4</h3>
<p>The Keil uVision projects for the ST evaluation boards use a custom flash programming algorithm for the external NOR flash, which must be copied to your uVision installation directory in order to be able to flash your application. You will find the flash loader algorithm here: </p><pre class="fragment">touchgfx_install_dir\app\template\EmptyApplication\target\ST\STM324x9I-CUBE\Keil\M29W128GL-ST.FLM
</pre><p> <br />
This file must be copied to the following folder (assuming that Keil uVision4 is installed in C:\Keil): </p><pre class="fragment">C:\Keil\ARM\Flash
</pre><p>After copying the flash algorithm file, please make sure that your uVision project settings correctly specify the use of this flash algorithm, and that the "RAM for algorithm" size is large enough (at least 0x2800 bytes): </p><div class="image">
<img src="keil-flash-st.png" alt="keil-flash-st.png"/>
<div class="caption">
Configuration of debuggger and flash algorithms in Keil uVision4 for ST eval boards</div></div>
 <h3><a class="anchor" id="sect_build_and_execute_target_keil_st_stm32f7"></a>
Downloading Applications for ST STM32756G-EVAL and STM32F746G-DISCO boards with Keil uVision5</h3>
<p>The Keil uVision projects for the STM32756G-EVAL and STM32F746G-DISCO boards use a custom flash programming algorithm for the external NOR flash (QSPI), which must be copied to your uVision installation directory in order to be able to flash your application. You can find the flash loader algorithms here: </p><pre class="fragment">touchgfx_install_dir\app\template\EmptyApplication\target\ST\STM32F746G-DISCO\STM32F7_Disco_Micron.flm
touchgfx_install_dir\app\template\EmptyApplication\target\ST\STM32756G-EVAL\STM32F7xx_QSPI_Micron.flm
</pre><p> <br />
This file must be copied to the following folder (assuming that Keil uVision5 is installed in C:\Keil_v5): </p><pre class="fragment">C:\Keil_v5\ARM\Flash
</pre><dl class="section note"><dt>Note</dt><dd>Updating your device packs through the Keil package manager would also give you access to the above flashloaders. For isntance, The flashloader for STM32756G-EVAL exists in device ST pack 2.2.0</dd></dl>
<pre class="fragment">i.e. C:\Keil_v5\ARM\Pack\Keil\STM32F7xx_DFP\2.2.0\Flash
</pre><p>After copying the flash algorithm file, please make sure that your uVision project settings correctly specify the use of this flash algorithm, and that the "RAM for algorithm" size is large enough (at least 0x2800 bytes. For EVAL, 0x5000). The F7 based boards are configured to use ST-Link per default.</p>
<div class="image">
<img src="keil-flash-stmf7-select.png" alt="keil-flash-stmf7-select.png"/>
<div class="caption">
Configuration of flash algorithms</div></div>
 <h2><a class="anchor" id="sect_build_and_execute_target_gcc"></a>
GCC Building applications with GNU GCC compiler for ARM</h2>
<p>TouchGFX offers GCC support for several hardware platforms (See <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_files_supported_hardware">Supported Hardware</a>), but does not provide or support any flash loaders officially. The MinGW development environment for Windows (See <a class="el" href="page_development_environment.html">Development Environment</a>) supports and comes with a pre-installed GNU GCC compiler suite for ARM processors. Those who don't use the MinGW development environment can download the GCC compiler suite <a href="https://launchpad.net/gcc-arm-embedded">here</a>. The version used by TouchGFX is currently 4.8.4 20140725 (labeled 4.8-2014-q3).</p>
<p>To build an application for i.e. the STM32429I-EVAL1 board, navigate to an application that supports this target (indicated by the contents of the target/ folder for any application) and execute the following command that will generate code from application assets and build the application.</p>
<pre class="fragment">$ make -f target/ST/STM32429I-EVAL1/gcc/Makefile
</pre><p>The <code>build/bin</code> folder now contains the following files:</p>
<ul>
<li><code>application.map</code> </li>
<li><code>extflash.bin</code> </li>
<li><code>intflash.elf</code> </li>
<li><code>intflash.hex</code> </li>
<li><code>target.elf</code> </li>
<li><code>target.hex</code> </li>
</ul>
<p>The build process outputs binaries for both internal and external flash for easier download, but also outputs a combined binary (<code>target.elf</code>) if you have access to a tool that can flash both internal and external flash from a single <code></code>.elf file. While you may use whatever tools you wish, but we supply a few methods below. </p><dl class="section note"><dt>Note</dt><dd>Binaries for external flash are not produced for targets with no external flash.</dd></dl>
<h2><a class="anchor" id="sect_build_and_execute_target_gcc_lpc4350"></a>
Programming TouchGFX demo board 4.3" LPC4350 when Compiling with GCC</h2>
<p>If using the GNU GCC compiler for ARM, boards with NXPs LPC4350 MCU (No internal flash) can flash an external, "Common Flash Interface" (CFI)-compliant NOR flash by using SEGGERs J-Link GDB Server (This requires a SEGGER J-Link debugger). The following describes, in detail, one process for flashing LPC4350 based boards, using the TouchGFX demo board 4.3", LPC4350 based, evaulation board as an example. The programming method described in this section can be generalized for other boards using the LPC4350 MCU and has a CFI compliant NOR flash.</p>
<p>The SEGGER J-Link GDB server can be downloaded <a href="https://www.segger.com/jlink-software.html">here</a> and the documentation can be found <a href="https://www.segger.com/admin/uploads/productDocs/UM08005_JLinkGDBServer.pdf">here</a>.</p>
<p>Let's start off by compiling the "Custom transition example" into an <code></code>.elf file that we can program onto the evaluation board. From the root of our TouchGFX installation we execute the following commands:</p>
<pre class="fragment">$ cd app/example/custom_transition_example
$ make -r -f target/Mjolner/TouchGFXDemoBoardRev1.1-4350-4.3/gcc/Makefile
&gt; Linking build/bin/target.elf
</pre><p> <br />
The following is an example GDB configuration file that sets up our GDB client with a few common settings for programming and debugging within the TouchGFX environment. Place this configuration in <code>~/</code>.gdbinit (If using the touchgfx windows development environment, this resolves to <code>/c/touchgfx-env/MinGW/msys/1</code>.0/home/{user}). Execute these commands manually if you want to avoid a central configuration.</p>
<pre class="fragment">set auto-load safe-path /

# Connect to the GDB Server
target remote :2331
file build/bin/target.elf
monitor reset
monitor halt
monitor endian little
monitor speed auto
monitor flash device LPC4350_M4
</pre><p> <br />
These commands perform the following steps automatically:</p>
<ol type="1">
<li>Connects to a GDB server listening on port 2331 (Default port)</li>
<li>Loads the <code>target.elf</code> file for the application we've just built using the <code>file</code> command. The argument provided to <code>file</code> is relative to the application root folder.</li>
<li>Resets the CPU and halts it so that we may read register values</li>
<li>Ensure little-endianness</li>
<li>Sets JTAG speed to auto</li>
<li>Lets GDB know which device we're flashing. This, combined with the information from the <code></code>.elf file will tell GDB about memory regions.</li>
</ol>
<p>Configure the connection to the SEGGER JLink GDB server:</p>
<div class="image">
<img src="segger_jlink_config.png" alt="segger_jlink_config.png"/>
</div>
  <br />
Start the SEGGER Jlink GDB Server and await incoming connections from GDB client:</p>
<div class="image">
<img src="segger_jlink_startup.png" alt="segger_jlink_startup.png"/>
</div>
  <br />
Connect to the GDB server using a <code>gdb</code> client. By not specifying any configuration file argument, <code>gdb</code> will default to <code>~/</code>.gdbinit.</p>
<pre class="fragment">$ gdb
&gt; GNU gdb (GDB) 7.6.1
</pre><p> <br />
The GDB server accepts the incoming connection:</p>
<div class="image">
<img src="segger_jlink_connected.png" alt="segger_jlink_connected.png"/>
</div>
 <p><br />
Execute the <code>load</code> command to initiate programming of the <code>build/bin/target.elf</code> file using SEGGERs J-Link flash-loader. Information about flash memory regions is read from the <code></code>.elf file and no further configuration is required.</p>
<pre class="fragment">(gdb) load
&gt;Loading section .text, size 0x95c8 lma 0x14000000
&gt;Loading section .rodata, size 0x2a84 lma 0x140095c8
&gt;Loading section ExtFlashSection, size 0xc8c00 lma 0x1400c04c
&gt;Loading section .init_array, size 0x10 lma 0x140d4c4c
&gt;Loading section .ARM.exidx, size 0x8 lma 0x140d4c5c
&gt;Loading section .data, size 0x8bc lma 0x140d4c64
&gt;Start address 0x14007ae1, load size 873760
&gt;Transfer rate: 12548 KB/sec, 15064 bytes/write.
</pre><p><br />
The GDB server will start downloading data based on the above load information.</p>
<div class="image">
<img src="segger_jlink_load.png" alt="segger_jlink_load.png"/>
</div>
 <p><br />
After programming of the external flash has finished, reset the CPU (<code>monitor</code> <code>reset</code>) and take it out of halt (<code>cont</code>).</p>
<pre class="fragment">(gdb) monitor reset
&gt;Resetting target
(gdb) cont
&gt;Continuing.
</pre><p> <br />
The application should now be running on target. Here's the GDB server log in it's entirety:</p>
<pre class="fragment">&gt;Resetting target
&gt;Target endianess set to "little endian"
&gt;Select auto target interface speed (2000 kHz)
&gt;Selecting device: LPC4350_M4
(gdb) load
&gt;Loading section .text, size 0x95c8 lma 0x14000000
&gt;Loading section .rodata, size 0x2a84 lma 0x140095c8
&gt;Loading section ExtFlashSection, size 0xc8c00 lma 0x1400c04c
&gt;Loading section .init_array, size 0x10 lma 0x140d4c4c
&gt;Loading section .ARM.exidx, size 0x8 lma 0x140d4c5c
&gt;Loading section .data, size 0x8bc lma 0x140d4c64
&gt;Start address 0x14007ae1, load size 873760
&gt;Transfer rate: 12548 KB/sec, 15064 bytes/write.
(gdb) monitor reset
&gt;Resetting target
(gdb) cont
&gt;Continuing.
</pre><h2><a class="anchor" id="sect_build_and_execute_target_gcc_lpc4353"></a>
Programming TouchGFX demo board 4.3"/7.0" LPC4353 when Compiling with GCC</h2>
<p>If using the GNU GCC compiler for ARM, boards with NXPs LPC4353 MCU can flash an external, "Common Flash Interface" (CFI)-compliant NOR flash by using Segger J-Flash software with a J-Link debugger. The following describes, in detail, one process for flashing LPC4353 based boards, using the TouchGFX demo board 4.3", LPC4353 based, evaluation board as an example. The programming method described in this section can be generalized for other boards using the LPC4353 MCU and has a CFI compliant NOR flash.</p>
<p>The SEGGER J-Flash software can be downloaded <a href="https://www.segger.com/jflash.html">here</a>.</p>
<p><b>Initial</b> <b>setup:</b> </p>
<p>To enable flashing of the LPC4353 demo board you have to add the following lines the J-Flash files:</p>
<p>Add</p><pre class="fragment">"NXP;LPC4353_M4 (SPIFI);LPC4353_M4 SPIFI;0E0000FF;0;0;0;4BA00477;14000000;10000000;A000" </pre><p> to the end of the <code>etc/jflash/mcu.csv</code> file.</p>
<p>Add</p><pre class="fragment">"NXP;LPC4353_M4 SPIFI;0;0;1;56;0;32;1;0;0;0;0;0;0;0;0;0;0;0;0;"20000[512];" </pre><p> to the end of the <code>etc/jflash/Flash.csv</code> file</p>
<p><b>Flashing:</b> </p>
<ol type="1">
<li>Open J-Flash and select "Create a new project".</li>
<li><p class="startli">Select "Options / Project Settings". In the "Project Settings" pop-up select the CPU tab. Choose the "Device" radio button and press the "..." button to select a new device. Type NXP and select the LPC4353_M4 entry. Press Apply and Ok to close the pop-up.</p>
<div class="image">
<img src="jflash_00.png" alt="jflash_00.png"/>
</div>
 <p class="startli"><br />
</p>
</li>
<li>Select "Target / Erase Chip (F4)"</li>
<li><p class="startli">Do the same as in step 2. except that you now select the LPC4353_M4(SPIFI) entry.</p>
<div class="image">
<img src="jflash_01.png" alt="jflash_01.png"/>
</div>
 <p class="startli"><br />
</p>
</li>
<li>Select "Target / Erase Chip (F4)". J-Flash might complain about unknown version of the device. In that case press "yes" and select NXP LPC4353_M4.</li>
<li>Flash external flash from address 14000000. To do this: Select "File / Open data file". Select the extflash.bin (default placed in <code>build/bin/</code>). Select "Target / Program (F5)".</li>
<li>Repeat step 2.</li>
<li>Flash internal flash: Select "File / Open data file". Select the intflash.hex (default placed in <code>build/bin/</code>). Select "Target / Program (F5)".</li>
<li>Power cycle the target.</li>
</ol>
<p>And the flashing should be completed.</p>
<h2><a class="anchor" id="sect_build_and_execute_target_gcc_st"></a>
Programming ST Boards when Compiling with GCC</h2>
<p>ST provides a Windows based utility, ST-Link, for flashing the internal and external flash of ST boards. You can download the <a href="http://www.st.com/web/en/catalog/tools/PF258168">STM32 ST-Link Utility here</a>. The process below outlines how to use the utility to program the internal and external flashes of the ST boards supported by TouchGFX. ST-Link will automatically detect the type of device connected and know how to flash the internal flash, but the external flashloader must be configured manually. Currently, TouchGFX supports the following boardpackages:</p>
<ol type="1">
<li>STM32469I-DISCO</li>
<li>STM32469I-EVAL</li>
<li>STM324x9I-CUBE</li>
<li>STM32756G-EVAL</li>
<li>STM32F429I-DISCO</li>
<li>STM32F746G-DISCO</li>
</ol>
<p>Instead of programming each flash individually, you may load the combined internal+external hex binary, target.hex. This will automatically detect the memory ranges to program, and select a suitable (if configured) flashloader to use.</p>
<pre class="fragment">[target.hex] opened successfully.
Address Ranges [0x08000000 0x08010364] [0x90000000 0x9000CA28] 
</pre><p>The procedure below outlines how to flash the internal and external individually. The accompanying screenshots are based on the STM324x9I-EVAL board.</p>
<p>Program the external flash:</p>
<ol type="1">
<li>Select "Add External Loader" from the "External Loader" menu.</li>
<li>Select the appropriate flashloader in the list of supported boards (i.e. MT25QL512A_STM32756G-EVAL for STM32756G-EVAL and N25Q128A_STM32F746G-DISCO for STM32F746G-DISCO).</li>
<li>Open the appropriate binary (<code>extflash.bin</code>). The start address is automatically provided.</li>
<li>Select "Program" from the External flash loader menu.</li>
</ol>
<p>Program the internal flash :</p>
<ol type="1">
<li>Open the appropriate binary (<code>intflash.hex</code>). The start address is automatically provided.</li>
<li>Select "Program" from the "Target" menu.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Consider having only a single external flashloader configured in ST-link active at any given time.</dd></dl>
<p><br />
</p><div class="image">
<img src="ST_LINK_Util_Menu_Add_External_Loader.png" alt="ST_LINK_Util_Menu_Add_External_Loader.png"/>
<div class="caption">
Step1 (Flash external): Add External Flash loader</div></div>
<p><br />
<br />
</p><div class="image">
<img src="ST_LINK_Util_add_external_loader.png" alt="ST_LINK_Util_add_external_loader.png"/>
<div class="caption">
Step 2 (Flash external): Select External Flash loader</div></div>
<p><br />
<br />
</p><div class="image">
<img src="ST_LINK_Util_Menu_Add_External_Loader_Program.png" alt="ST_LINK_Util_Menu_Add_External_Loader_Program.png"/>
<div class="caption">
Step 3 (Flash external): Select Program</div></div>
<p><br />
<div class="image">
<img src="ST_LINK_Util_Download_Ext_Flash.png" alt="ST_LINK_Util_Download_Ext_Flash.png"/>
<div class="caption">
Step 4 (Flash external): Download binary</div></div>
<p><br />
<br />
</p><div class="image">
<img src="ST_LINK_Util_Menu_ProgramIntFlash.png" alt="ST_LINK_Util_Menu_ProgramIntFlash.png"/>
<div class="caption">
Step 1 (Flash internal): Select Program </div></div>
<p><br />
<br />
</p><div class="image">
<img src="ST_LINK_Util_Download_Int_Flash.png" alt="ST_LINK_Util_Download_Int_Flash.png"/>
<div class="caption">
Step 2 (Flash internal): Download binary</div></div>
<p><br />
<br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
