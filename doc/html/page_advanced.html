<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TouchGFX: Advanced</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="touchgfx.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="touchgfxlogo.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TouchGFX
   &#160;<span id="projectnumber">v4.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_advanced.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page contains a number of advanced topics relating to inner workings of TouchGFX. It is not mandatory reading and certainly not intended to be read in its entirety by everyone using TouchGFX. Instead, the chapters here will be referenced from other places of the documentation where relevant, such as from the <a class="el" href="page_porting.html">Porting Guide</a>.</p>
<h1><a class="anchor" id="sect_adv_bitmap_caching"></a>
Bitmap Caching</h1>
<p>TouchGFX provides a mechanism for caching bitmap data in volatile memory. The memory area where the cache is placed will usually be the external RAM where the frame buffers are also placed. There are two main scenarios in which bitmap caching is useful:</p><ul>
<li>On platforms where accessing the external flash is slower than accessing the external RAM, thereby offering performance increase by keeping a cached copy of select bitmaps on particularly taxing screens.</li>
<li>On platforms where the external flash is not memory-mapped, which means that all bitmaps must be cached. This is the case when using e.g. an SD card, a NAND flash or a serial flash to store bitmap data.</li>
</ul>
<p>In the first case, only select bitmaps would be cached. In the second case, all bitmaps in the application must be cached, because TouchGFX is not able to render from locations that cannot be accessed in a memory mapped fashion, e.g. through a pointer.</p>
<dl class="section note"><dt>Note</dt><dd>Bitmap caching is not supported for 1BPP monochrome.</dd></dl>
<h2><a class="anchor" id="sect_adv_caching_configuration"></a>
Configuring the Bitmap Cache</h2>
<p>There are a few things which need to be configured before the bitmap caching mechanism can be used on your platform. This is described in the chapter <a class="el" href="page_porting.html#sect_porting_altflash">Non-memory mapped external flash / Supporting bitmap caching</a> of the <a class="el" href="page_porting.html">Porting Guide</a>.</p>
<h2><a class="anchor" id="sect_adv_caching_use"></a>
Using the Bitmap Cache</h2>
<p>With the bitmap caching mechanism properly configured, it is ready to be used in applications. For caching a single bitmap, simply call the function <a class="el" href="classtouchgfx_1_1_bitmap_a6c61debf04d6761f37daa6550108b63d.html#a6c61debf04d6761f37daa6550108b63d">touchgfx::Bitmap::cache</a>. If this function returns true, the bitmap is now cached, and all subsequent renderings of this bitmap will read from cache memory instead of the flash storage. A good place to call this function would be the setupScreen function of the View which needs to display this bitmap. If the bitmap was already cached, the cache function will return instantly so it is safe to call every time a View is entered.</p>
<p>If all bitmaps must be cached because they are located in a non-memory-mapped flash type, use the function <a class="el" href="classtouchgfx_1_1_bitmap_aca4ced32fe539517e2dfec3fbab4d57e.html#aca4ced32fe539517e2dfec3fbab4d57e">touchgfx::Bitmap::cacheAll</a>. This function might take some time (several seconds) to execute depending on the amount of bitmaps and the memory transfer speed. It is therefore often desirable to create some sort of boot screen displaying a progress indicator while the caching operation takes place. To implement a progress indicator, you should call the cacheAll function from another task with lower priority than the GUI task (as it will otherwise freeze the UI until the caching operation is complete).</p>
<h1><a class="anchor" id="sect_adv_bitmap_location"></a>
Changing the Location of Bitmap Data</h1>
<p>The default behavior is that all bitmaps are placed in external flash. This is because bitmap data take up a lot of space, and most applications will have more bitmaps than fits in the internal flash. The placement of bitmap data is managed by a linker section placement attribute which is affixed to each auto-generated array of pixel data. </p><div class="fragment"><div class="line">LOCATION_EXTFLASH_PRAGMA</div>
<div class="line">KEEP <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _down_btn[] LOCATION_EXTFLASH_ATTRIBUTE = { <span class="comment">// 130x56 RGB565 pixels.</span></div>
</div><!-- fragment --><p> The LOCATION_ symbols above are compiler specific defines which translates to a way of labelling the data array with a section name called ExtFlashSection. Thus the linker script can be used to control whether bitmap data should be located in internal or external flash.</p>
<p>There is also an option for more fine grained control of the placement of each individual bitmap. If, for instance, one particular bitmap should be placed in internal flash because it is used in a very performance-critical animation, the bitmap file name can be changed to contain ".int.": </p><div class="fragment"><div class="line">logotexturemap.int.png</div>
</div><!-- fragment --><p>This causes the pixel data array for this image to <em>not</em> contain a linker placement directive, so that it instead will be placed in the default readonly data segment (typically internal flash): </p><div class="fragment"><div class="line">KEEP <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _logotexturemap_int[]  = { <span class="comment">// 152x154 RGB565 pixels.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sect_adv_timing"></a>
Timing and TFT Controller Integration</h1>
<p>For performance reasons, the timing of TouchGFX is strongly connected with the operation of the TFT controller. Therefore in order to understand TouchGFX timing, we must first look into how a TFT controller operates.</p>
<p>The TFT controller on an MCU is responsible for updating the display glass with the pixel values found in the frame buffer. The display glass itself does not have any memory, so the pixel values must be transmitted to the display continuously, regardless of whether or not the frame buffer contents change. So even when displaying a still image, the frame buffer is being transferred to the display.</p>
<p>The display update frequency varies among displays, but it is usually in the 50-60 Hz range. That means, every 16-20 milliseconds the frame buffer contents are being transferred. The transfer usually happen in bursts with a shorter duration than the update frequency, leaving some idle time between each update where the memory holding the frame buffer can be accessed for other means (like, for instance, writing new pixel values in the frame buffer).</p>
<p>The following figure shows the update cycle of a TFT controller on a 320x240 pixel display: </p><div class="image">
<img src="tft-controller.png" alt="tft-controller.png"/>
<div class="caption">
Timing Diagram of TFT controller</div></div>
 The porch areas are delays where no data is being sent. Pixel data is transferred one pixel at a time, starting from the top left corner of the display (pixel 0,0) traversing horizontally, with delays before and after each line (horizontal porches) and delays before first line and after last line (vertical porches). For every display update (frame) a VSYNC signal is issued, and for each line in that frame, a HSYNC signal is issued. Whenever the controller is inside the active area, the SDRAM containing the frame buffer is busy. In order to optimize SDRAM access, the controller signals are directly connected to when TouchGFX performs its rendering, as explained in the following.</p>
<h2><a class="anchor" id="sect_adv_timing_rendering"></a>
Rendering Pass</h2>
<p>A frame rendering pass begins when the TFT controller enters the active area. The rendering pass consists of the following steps:</p>
<ol type="1">
<li>Call the virtual <a class="el" href="classtouchgfx_1_1_h_a_l_aefc83109892049d0ae85476a96998e2c.html#aefc83109892049d0ae85476a96998e2c">beginFrame</a> function</li>
<li>Call <a class="el" href="classtouchgfx_1_1_application_ad39a7a733e398154f1bddefbbcd0bb32.html#ad39a7a733e398154f1bddefbbcd0bb32">Application::handleTickEvent</a> function, which will tick timer widgets and the active view. This step may cause invalidation of the screen.</li>
<li>Sample touch and forward touch events to the application. This step may also cause invalidation.</li>
<li>Sample keys and buttons if appropriate and forward these to the application. This step may also cause invalidation.</li>
<li>Coalesce invalidated areas and begin actual drawing where needed</li>
<li>Wait for drawing to be completed</li>
<li>Call the virtual <a class="el" href="classtouchgfx_1_1_h_a_l_a275cb0fc5850b339346d533d2e65aaa8.html#a275cb0fc5850b339346d533d2e65aaa8">endFrame</a> function</li>
</ol>
<h2><a class="anchor" id="sect_adv_timing_framerate"></a>
Frame Rate</h2>
<p>If the time it takes to render the screen is less than the display update rate, the actual frame rate of the system will match the display update rate. This will usually happen if nothing or only a small portion of the screen needs to be drawn. If, however, the drawing takes longer, the actual frame rate will decrease because the next frame rendering pass will not happen the next time the TFT controller enters the active area, since the previous drawing was still underway. The following figure outlines the timing associated with a typical rendering pass, spanning four frames, where all rendering passes take less time than the display update frequency. </p><div class="image">
<img src="rendering-pass-overview.png" alt="rendering-pass-overview.png"/>
<div class="caption">
Timing diagram showing four frames</div></div>
<p>What you see above is that the GUI task begins its frame rendering immediately when the TFT controller enters the active area (ie. begins updating the display), labeled a). The GUI task will sample touch and buttons, and call tick on the active view and any widgets that have registered for timer events. In this example, this causes an invalidation of a region of the screen. At b), rendering is completed, and the GUI task can now sleep. At c), the TFT controller begins updating the display (entering the active area for the next frame). Here several things happen: since we have redrawn parts of the screen, we swap frame buffers, such that the TFT controller will use the frame buffer in which we just drew as base for updating the display in this cycle. Additionally, the GUI task wakes again and begins the next frame rendering pass. In this example figure, no screen changes were required in this pass, so the GUI task will quickly sleep (d) and the system idles until next frame. You will also note that no frame buffer swap takes place at next display update (e) because nothing was drawn.</p>
<p>If the screen area that needs to be drawn is large, it is quite possible that the drawing operations take longer than the display update frequency, as illustrated here: </p><div class="image">
<img src="rendering-pass-overrun-fast.png" alt="rendering-pass-overrun-fast.png"/>
<div class="caption">
Example where redrawing takes longer than VSYNC frequency</div></div>
<p>Here you will notice the rendering process is still underway when the next TFT controller update begins (a). Since the previous frame was not complete, this event is ignored so no new frame rendering pass begins here. The frame buffer swap will occur at next TFT update after the rendering is completed (b). In this example, the <em>effective</em> frame rate (ie. the frequency with which the pixels on the display actually change) is VSYNC/2. If the drawing operation took a very long time, it might even span across three or four updates. This is not a problem if it only happens on occasions such as switching to a different view. But if it happens during an animation that is supposed to look fluent the effective frame rate will be too slow.</p>
<p>Because the frame buffer swapping takes places at the next display update after drawing is complete, it may be necessary to adjust the VSYNC frequency in order to obtain the optimal timing. Consider the following example: </p><div class="image">
<img src="rendering-pass-overrun-slow.png" alt="rendering-pass-overrun-slow.png"/>
<div class="caption">
Example where VSYNC frequency is suboptimal with regards to drawing</div></div>
 What you see above is that rendering completes immediately <em>after</em> the display begins updating (a). At this point the frame buffer swap cannot occur because the TFT controller is in the middle of updating the display. Therefore the swap cannot take place until next update, which means that the pixel update will not be visible until next update (b). This yields an effective frame rate of VSYNC/3.</p>
<p>In such a scenario it would actually be better to slow down the TFT update frequency e.g. by extending the vertical porches. The following figure illustrates the same drawing operation, but with a slightly lower VSYNC frequency: </p><div class="image">
<img src="rendering-pass-overrun-slow-fixed.png" alt="rendering-pass-overrun-slow-fixed.png"/>
<div class="caption">
Same scenario with slower VSYNC frequency, yielding better results</div></div>
<p>The porch delay area has been slightly extended (a). Now the rendering completes immediately <em>before</em> a TFT update, thus allowing the frame buffers to be swapped earlier, yielding a better effective frame rate.</p>
<p>Because of this, the optimal VSYNC timing of your system can be hard to determine before the UI has been implemented. A good rule of thumb is to aim for a 16-20ms update frequency initially, and investigate the actual rendering times of your application to fine tune.</p>
<h2><a class="anchor" id="sect_adv_timing_interleaved"></a>
Interleaving MCU- and DMA-based Rendering</h2>
<p>For the sake of simplicity, all the examples above simply show the rendering time and does not distinguish whether the rendering is done by DMA or MCU. TouchGFX will attempt to use the DMA as much as possible in order for the MCU load to remain low. Depending on your target microcontroller and the composition of your user interface, it is not uncommon for the GUI task itself to also perform rendering, however, for instance when drawing text or alpha blended images if this is not supported by the DMA engine. See <a class="el" href="page_advanced.html#sect_adv_blitcaps">Blitting Operations and Hardware Blit Capabilities</a> for details on hardware support. If software rendering is involved, a more detailed timing diagram is as follows: </p><div class="image">
<img src="rendering-pass-software.png" alt="rendering-pass-software.png"/>
<div class="caption">
Example where the GUI task performs some rendering operations</div></div>
In the above figure we see the GUI task wake up (a) and begin processing the frame (sampling touch, handling timer ticks, create a queue of DMA operations). When this is done, the DMA takes over (b). We then see the GUI task performing MCU based rendering at c), and with subsequent interleaved DMA and MCU based drawing for the remainder of the rendering process.</p>
<p>The synchronization of the interleaving process is built into TouchGFX and controlled by a frame buffer semaphore, which allows the GUI task and the DMA to alternately perform drawing operations in the frame buffer.</p>
<h2><a class="anchor" id="sect_adv_timing_framebuffers"></a>
Number of Frame Buffers</h2>
<p>TouchGFX can be configured to use either a single frame buffer or double buffering. This configuration is done through the <a class="el" href="classtouchgfx_1_1_h_a_l_ab6cb18edd347470dda687d7c13dae035.html#ab6cb18edd347470dda687d7c13dae035">HAL::setFrameBufferStartAddress</a> function which is usually called in your board configuration file. The default operation is to use double buffering.</p>
<p>We strongly recommend using double-buffering even though it takes up additional external memory space. The reason is that if using single buffering, <em>all</em> drawing operations must be able to complete within a single TFT update cycle. If it takes longer, the frame buffer contents are being changed while at the same time being transferred to the display by the TFT controller. The result of this will be visible artifacts on the screen such as tearing. The TouchGFX rendering algorithm has been specifically designed such that it has a tendency to draw the upper parts of the screen first, regardless of how the UI is composed. This may help in the sense that a short overlap in most cases will not cause tearing, but is not really something to count on. Even so, screens with much alpha blending will be close to impossible to render in a single frame.</p>
<p>The only two occasions where single buffering might be of use are:</p><ul>
<li>If the resolution is small enough to fit the frame buffer in internal RAM. The rendering time will in this case normally be fast enough to complete in a single update cycle, even for complex screens with alpha blending.</li>
<li>If the hardware platform simply does not have enough external RAM for two buffers. But in this case you should probably be prepared to accept limitations in UI design.</li>
</ul>
<p>As mentioned, when using single buffering, it is not allowed to draw in the frame buffer while the TFT controller is in the active area. This is handled by TouchGFX by waiting for a TFT controller signal indicating that the active area has been exited before starting any DMA or MCU based rendering, as illustrated here: </p><div class="image">
<img src="rendering-pass-single.png" alt="rendering-pass-single.png"/>
<div class="caption">
Single-buffered rendering scenario</div></div>
Also in single-buffering mode, the rendering pass begins when TFT controller enters active area. But nothing will actually be drawn until TFT controller is done updating (b), where the DMA queue will begin transferring. The frame rendering completes at c), well before the next display update, so no glitches appear. A second frame begins at d), where more complex graphics were drawn so the rendering pass took longer and did not complete in time (e). This frame would likely cause graphics glitches, and it would be necessary to either speed up the rendering, increasing porch timing or switching to double buffering to alleviate this.</p>
<h1><a class="anchor" id="sect_adv_animation_storage"></a>
Animation Storage</h1>
<p>In TouchGFX, animation storage is an optional storage placed in external RAM along with the frame buffer(s). If used, it will take up the same amount of memory as a frame buffer (ie. displayWidth * displayHeight * pixelsizeInBytes). The purpose of the animation storage is to provide memory for taking a snapshot of the current contents of the frame buffer and use it for certain animations. Currently it is only used when employing <a class="el" href="classtouchgfx_1_1_slide_transition.html">SlideTransitions</a> where a snapshot of the "old" view is used in the sliding animation. If no animation storage is allocated, SlideTransition will behave like NoTransition, ie. an instant screen switch without animation.</p>
<p>The configuration of whether to enable animation storage is done through the <a class="el" href="classtouchgfx_1_1_h_a_l_ab6cb18edd347470dda687d7c13dae035.html#ab6cb18edd347470dda687d7c13dae035">HAL::setFrameBufferStartAddress</a> function. The default behavior is enabled.</p>
<h1><a class="anchor" id="sect_adv_blitcaps"></a>
Blitting Operations and Hardware Blit Capabilities</h1>
<p>In the context of TouchGFX, blit capabilities refer to which types of blitting operations the hardware is able to perform. This varies considerably across hardware platforms and mainly depend on how advanced the DMA controller on the MCU is. The hardware abstraction layer must define which blitting operations the hardware is able to carry out natively. Those that are not supported directly by hardware, will automatically be rendered using built-in software fallback routines instead. </p><dl class="section note"><dt>Note</dt><dd>It will always mean higher MCU load, and often also slower rendering times to use the software routines.</dd></dl>
<p>The blitting operations used in TouchGFX are: </p><table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Usage  </th></tr>
<tr>
<td>BLIT_OP_COPY </td><td>This blitting operation refers to a basic copy of data from e.g. an image to the frame buffer. It is the most common operation in TouchGFX and is used when rendering an image that does not use per-pixel-alpha, contains no transparent pixels, and the source and destination formats match. Since it is, essentially, a memcpy(), this operation will almost always be supported by the hardware.  </td><td>An <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget displaying an RGB565 bitmap  </td></tr>
<tr>
<td>BLIT_OP_FILL </td><td>This blitting operation refers to a basic fill of a single color value to a region, e.g. rendering a solid color box to the frame buffer. This operation is also supported on most hardware. </td><td>A <a class="el" href="classtouchgfx_1_1_box.html">Box</a> widget  </td></tr>
<tr>
<td>BLIT_OP_COPY_WITH_ALPHA </td><td>This operation is similar to BLIT_OP_COPY, but where a specific alpha blend factor is applied to each pixel. Requires an advanced DMA controller in order to support this operation in hardware.  </td><td>An <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget displaying a standard RGB565 bitmap but with an alpha value set on the widget.  </td></tr>
<tr>
<td>BLIT_OP_FILL_WITH_ALPHA </td><td>This operation is similar to BLIT_OP_FILL, but where a specific alpha blend factor is applied to each pixel. Requires an advanced DMA controller in order to support this operaetion in hardware. </td><td>A <a class="el" href="classtouchgfx_1_1_box.html">Box</a> widget with an alpha value set.  </td></tr>
<tr>
<td>BLIT_OP_COPY_WITH_TRANSPARENT_PIXELS </td><td>This operation is a basic copy, but where a certain pixel value means transparency (i.e. that pixel should be skipped). This operation has been superseded by the more powerful per-pixel-alpha operations and is therefore not used. There is no reason to implement support for this blit operation. </td><td>An <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget displaying an RGB565 image containing pixels of color <a class="el" href="classtouchgfx_1_1_l_c_d16bpp.html#a2fb18cd753efe8160653d43f97f3eabe">touchgfx::LCD16bpp::TRANSPARENT_COL</a>  </td></tr>
<tr>
<td>BLIT_OP_COPY_ARGB8888 </td><td>This operation is a data copy where a format conversion is being applied for each pixel. In this case, source data is a 32-bit per pixel value (with an 8 bit alpha channel). This must be downscaled to 16 bits and blended with the background pixel color according to the alpha channel. Requires an advanced DMA with format conversion capabilities to support in hardware.  </td><td>An <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget display an ARGB8888 bitmap (image converter output format ARGB8888)  </td></tr>
<tr>
<td>BLIT_OP_COPY_ARGB8888_WITH_ALPHA </td><td>As above, but also apply a generic alpha blend to each pixel. </td><td>An <a class="el" href="classtouchgfx_1_1_image.html">Image</a> widget displaying an ARGB8888 bitmap and which also has an alpha value set.  </td></tr>
<tr>
<td>BLIT_OP_COPY_A4 </td><td>This operation is used for rendering data represented as a 4-bit alpha channel only (i.e. no color information). Requires an advanced DMA with format conversion capabilities in order to support this operation in hardware. </td><td>Used for rendering text, when glyph data format is configured to be 4bpp in the text database.  </td></tr>
<tr>
<td>BLIT_OP_COPY_A8 </td><td>As above, with an 8bpp alpha channel. </td><td>Used for rendering text, when glyph data format is configured to be 8bpp in the text database.  </td></tr>
</table>
<h1><a class="anchor" id="sect_adv_languages"></a>
Languages and Chars</h1>
<p>TouchGFX supports displaying text in many different languages and charsets. There are however some limitations, which means that not all languages are supported out of the box.</p>
<h2><a class="anchor" id="sect_adv_glyphlimits"></a>
Glyph Limitations</h2>
<p>Due to the encoding scheme used by TouchGFX, we only support displaying glyphs whose Unicode code point is below 65536 (U+FFFF).</p>
<h2><a class="anchor" id="sect_adv_textlimits"></a>
Text Limitations</h2>
<ul>
<li>Text direction: TouchGFX supports only left-to-right writing direction.</li>
<li>Complex Text Layout (e.g. context-sensitive shaping, digraphs and presentation forms) are not supported.</li>
</ul>
<h2><a class="anchor" id="sect_adv_shippedlangs"></a>
List of Supported Languages</h2>
<p>TouchGFX products have shipped with the following languages:</p><ul>
<li>Bosnian</li>
<li>Bulgarian</li>
<li>Chinese</li>
<li>Croatian</li>
<li>Czech</li>
<li>Danish</li>
<li>Dutch</li>
<li>English</li>
<li>Estonian</li>
<li>Finnish</li>
<li>French</li>
<li>German</li>
<li>Hungarian</li>
<li>Italian</li>
<li>Japanese</li>
<li>Latvian</li>
<li>Lithuanian</li>
<li>Norwegian</li>
<li>Polish</li>
<li>Portuguese</li>
<li>Russian</li>
<li>Romanian</li>
<li>Serbian</li>
<li>Slovenian</li>
<li>Slovak</li>
<li>Spanish</li>
<li>Swedish</li>
<li>Turkish</li>
<li>Ukrainian</li>
</ul>
<h2><a class="anchor" id="sect_adv_unsupportedlangs"></a>
Unsupported Languages</h2>
<p>The following languages are known to be unsupported because they rely on right-to-left writing direction and/or make extensive use of ligatures and digraphs:</p><ul>
<li>Arabic</li>
<li>Hebrew</li>
<li>Thai</li>
</ul>
<h1><a class="anchor" id="sect_advanced_perfmeas"></a>
Performance Measurement</h1>
<p>Two methods</p>
<h2><a class="anchor" id="GPIO"></a>
GPIO</h2>
<p>The <a class="el" href="classtouchgfx_1_1_g_p_i_o.html">touchgfx::GPIO</a> class, compiled for all target applications, contains methods to <code>set</code>, <code>clear</code>, <code>toggle</code> and <code>get</code> the state of a GPIO pin. An implementation must be provided for these static members; Even if it is simply empty and does nothing. While the TouchGFX core might not be available to you, our code is instrumented to make calls into this GPIO implementation when it performs certain functions to help developers track down performance and timing issues. The following types are toggled throughout TouchGFX:</p>
<ol type="1">
<li><code>VSYNC_FREQ</code> is typically toggled from the HAL component of an MCU</li>
<li><code>RENDER_TIME</code> defines the length of a frame, and is toggled from HAL base class</li>
<li><code>FRAME_RATE</code> defines the time it takes to swap framebuffers and is toggled from the HAL base class upon swap requests</li>
<li><code>MCU_ACTIVE</code> is toggled from the idle task hook in the <a class="el" href="classtouchgfx_1_1_o_s_wrappers.html" title="This class specifies OS wrappers for dealing with the frame buffer semaphore and the VSYNC signal...">touchgfx::OSWrappers</a> class for an OS package as soon as the idle task is scheduled</li>
</ol>
<p>You can perform measurements with an oscilloscope by toggling the GPIO pins of choice in your implementation of the GPIO class. You can gain inspiration from existing GPIO implementations for various boards found under the <code>touchgfx/board</code> folder.</p>
<h2><a class="anchor" id="sect_advanced_perfmeas_mcuinstr"></a>
MCU Instrumentation</h2>
<p>The class <a class="el" href="classtouchgfx_1_1_m_c_u_instrumentation.html">touchgfx::MCUInstrumentation</a> provides an interface for reading out CPU-cycles in an effort to, for instance, calculate general MCU-load caused by an application. The following items are required in order to enable HAL to perform MCU load calculations:</p>
<ol type="1">
<li>Configure OS to set MCU active when Idle Task is switched out during rescheduling.</li>
<li>Configure HAL with a concrete instance of <code>MCUInstrumentation</code> for a particular processor (For Cortex-M: <a class="el" href="classtouchgfx_1_1_cortex_m_m_c_u_instrumentation.html">touchgfx::CortexMMCUInstrumentation</a> located under <code>platform/core/arm/cortex-m</code>)</li>
</ol>
<h2><a class="anchor" id="sect_overview_framework_mcuinstr_hal"></a>
HAL</h2>
<p>The following code snippet from a BoardConfiguration shows how to configure HAL to use MCU instrumentation.</p>
<div class="fragment"><div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"> CortexMMCUInstrumentation mcuInstr;</div>
<div class="line">    </div>
<div class="line"> <span class="keywordtype">void</span> <a class="code" href="namespacetouchgfx_ae6e21dbb033844e61723026bf9b9a4ad.html#ae6e21dbb033844e61723026bf9b9a4ad">touchgfx_init</a>()</div>
<div class="line"> {   </div>
<div class="line">   HAL&amp; hal = touchgfx_generic_init&lt;STM32F4HAL&gt;(dma, display, tc, 480, 272, 0, 0);</div>
<div class="line">   hal.setFrameBufferStartAddress((uint16_t*)frameBuf0);</div>
<div class="line">  </div>
<div class="line">   mcuInstr.init();</div>
<div class="line">      </div>
<div class="line">   <span class="comment">//Set MCU instrumentation and Load calculation</span></div>
<div class="line">   hal.setMCUInstrumentation(&amp;mcuInstr);</div>
<div class="line">   hal.enableMCULoadCalculation(<span class="keyword">true</span>);  </div>
<div class="line">  }</div>
</div><!-- fragment --><h2><a class="anchor" id="sect_overview_framework_mcuinstr_os"></a>
OS</h2>
<p>The following snippet shows how <code>OSWrappers.cpp</code> (Wrapper for FreeRTOS7.6.0), through a task hook, is able to indicate when the MCU is active and when it is Idle. We use the FreeRTOS method <code>vTaskSetApplicationTaskTag</code> to callback function and assign our function pointer <code>IdleTaskHook</code> as the task tag parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> portBASE_TYPE IdleTaskHook(<span class="keywordtype">void</span>* p)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)p) <span class="comment">//idle task sched out</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classtouchgfx_1_1_h_a_l_a9851dbb1edc99dbbe6ee5b876f79b40f.html#a9851dbb1edc99dbbe6ee5b876f79b40f">touchgfx::HAL::getInstance</a>()-&gt;<a class="code" href="classtouchgfx_1_1_h_a_l_a4e2c2a8b8af2098feed65c6908547691.html#a4e2c2a8b8af2098feed65c6908547691">setMCUActive</a>(<span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="comment">//idle task sched in</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classtouchgfx_1_1_h_a_l_a9851dbb1edc99dbbe6ee5b876f79b40f.html#a9851dbb1edc99dbbe6ee5b876f79b40f">touchgfx::HAL::getInstance</a>()-&gt;<a class="code" href="classtouchgfx_1_1_h_a_l_a4e2c2a8b8af2098feed65c6908547691.html#a4e2c2a8b8af2098feed65c6908547691">setMCUActive</a>(<span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> pdTRUE;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// FreeRTOS specific handlers</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> vApplicationStackOverflowHook( xTaskHandle xTask, </div>
<div class="line">                                      <span class="keywordtype">signed</span> portCHAR *pcTaskName )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">while</span>(1);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> vApplicationMallocFailedHook( xTaskHandle xTask, </div>
<div class="line">                                   <span class="keywordtype">signed</span> portCHAR *pcTaskName )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">while</span>(1);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">void</span> vApplicationIdleHook( <span class="keywordtype">void</span> )</div>
<div class="line">  {</div>
<div class="line">    vTaskSetApplicationTaskTag( NULL, IdleTaskHook );</div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Enabling the <em>Idle-hook</em> is an explicit setting found in <code>FreeRTOSConfig.h</code> for a specific application. The following snippets were taken from <code>app/demo/touchgfx_demo2014_480x272/platform/os/FreeRTOSConfig.h</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define configUSE_IDLE_HOOK                     1</span></div>
</div><!-- fragment --><p>The following define configuration is required to call the idle hook when a task is switched out.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define traceTASK_SWITCHED_OUT() xTaskCallApplicationTaskHook( pxCurrentTCB, (void*)1 )</span></div>
<div class="line"><span class="preprocessor">#define traceTASK_SWITCHED_IN() xTaskCallApplicationTaskHook( pxCurrentTCB, (void*)0 )</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sect_overview_framework_platform"></a>
Platform Abstraction</h1>
<p>The folder <code>platform/core</code> contains a vendor-independent hardware abstraction layer for Cortex-M processors (<a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS - Cortex Microcontroller Software Interface Standard</a>). Also in <code>core</code> lies source allowing retrieval of elapsed CPU cycles and measurement of CPU load in TouchGFX applications. For more information on how to enable MCU instrumentation, see <a class="el" href="page_advanced.html#sect_advanced_perfmeas_mcuinstr">MCU Instrumentation</a>. <code>driver</code> contains generic driver interfaces used by <em>board</em> <em>packages</em> (See <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_board">Board Packages (touchgfx/board/)</a>) to configure platform peripherals and the <code>hal</code> folder contains MCU specific TouchGFX ports - See <a class="el" href="page_porting.html">Porting Guide</a>. </p><pre class="fragment">+-- platform
|    +-- core
|    |-- driver
|    |      +-- button
|    |      |-- i2c
|    |      \-- touch
|    |      
|    \-- hal
|         +-- Freescale
|         |-- nxp
|         |-- simulator
|         \-- ST
</pre><p><br />
 TouchGFX offers a small range of generic, reusable driver interfaces for configuration of hardware peripherals.</p>
<ul>
<li><code>button</code> contains generic button controller interfaces. Concrete implementations are practically always board-specific.</li>
<li><code>i2c</code> contains generic I2C driver interfaces. Concrete implementations are always MCU specific.</li>
<li><code>touch</code> contains generic touch controller interfaces. Concrete implementations are generic and can be used with any board that utilises a supported touchcontroller.</li>
</ul>
<h2><a class="anchor" id="sect_overview_framework_platform_drivers_buttonctrl"></a>
Button Controllers</h2>
<p>Button Controllers (<a class="el" href="classtouchgfx_1_1_button_controller.html">touchgfx::ButtonController</a>) can be used to add hardware button support to TouchGFX applications. A concrete implementaiton of a Button Controller is typically located under the Board Support <code>bsp</code> folder in a board configuration. The folder <code>button</code> contains a single interface description <a class="el" href="classtouchgfx_1_1_button_controller.html">touchgfx::ButtonController</a> that exposes methods for initializing and sampling. The <code>sample()</code> method <a class="el" href="classtouchgfx_1_1_button_controller_a2850d76bc1f671ccf2b18d1b4b1e5402.html#a2850d76bc1f671ccf2b18d1b4b1e5402">touchgfx::ButtonController::sample</a> returns whether or not a keypress was detected, and stores the numerical value for the key that was pressed in an 8-bit reference.</p>
<p>During <a class="el" href="classtouchgfx_1_1_h_a_l_a873dd91783f9efb4a590aded1f70d6b0.html#a873dd91783f9efb4a590aded1f70d6b0">touchgfx::HAL::tick</a> a configured Button Controller is used to sample for pressed buttons and listeners are notified. In the pseudo example below, a <code>KeySampler</code> tests for the status of 5 buttons. Reading the state of an appropriate GPIO port through the <code>Buttons</code> class gives us a button state sample that can be used by the <code>sample</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;KeySampler.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;touchgfx/HAL/Buttons.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> KeySampler::init()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classtouchgfx_1_1_buttons_aedc913c139bb562646d3459b0ca28997.html#aedc913c139bb562646d3459b0ca28997">Buttons::init</a>();    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> KeySampler::sample(uint8_t&amp; key)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> buttons = <a class="code" href="classtouchgfx_1_1_buttons_a9fd8c68329e890dd0001fa774edf244f.html#a9fd8c68329e890dd0001fa774edf244f">Buttons::sample</a>();</div>
<div class="line"></div>
<div class="line">   <span class="comment">//Return true if button was pressed, save 1 to key argument </span></div>
<div class="line">   <span class="comment">//Return true if button was pressed, save 2 to key argument </span></div>
<div class="line">   <span class="comment">//Return true if button was pressed, save 3 to key argument </span></div>
<div class="line">   <span class="comment">//Return true if button was pressed, save 4 to key argument </span></div>
<div class="line">   <span class="comment">//Return true if button was pressed, save 5 to key argument </span></div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Configuring HAL with a button controller using <a class="el" href="classtouchgfx_1_1_h_a_l_a87c1f6c423f7ac101443cce375ea67ae.html#a87c1f6c423f7ac101443cce375ea67ae">touchgfx::HAL::setButtonController</a> will cause sampling for pressed buttons every tick.</p>
<h2><a class="anchor" id="sect_overview_framework_platform_drivers_i2c"></a>
i2c</h2>
<p>The <code>i2c</code> folder contains a generic interface for concrete I2C driver implementations in TouchGFX (See <a class="el" href="classtouchgfx_1_1_i2_c.html">touchgfx::I2C</a>). I2C drivers are always MCU specific and currently TouchGFX supports generic I2C drivers for NXPs LPC43XX (<a class="el" href="classtouchgfx_1_1_i2_c___l_p_c43xx.html">touchgfx::I2C_LPC43xx</a>) and LPC1788 (<a class="el" href="classtouchgfx_1_1_i2_c___l_p_c1788.html">touchgfx::I2C_LPC1788</a>) series. In general, only the <code>readRegister()</code> method is used for touch controller purposes.</p>
<h2><a class="anchor" id="sect_overview_framework_platform_drivers_touch"></a>
Touch Controllers</h2>
<p>The <code>touch</code> folder contains generic interfaces for touch controllers (<a class="el" href="classtouchgfx_1_1_touch_controller.html">touchgfx::TouchController</a>) in TouchGFX.</p>
<p>During <a class="el" href="classtouchgfx_1_1_h_a_l_a873dd91783f9efb4a590aded1f70d6b0.html#a873dd91783f9efb4a590aded1f70d6b0">touchgfx::HAL::tick</a>, the configured touch controller is sampled <a class="el" href="classtouchgfx_1_1_touch_controller_a48b5d61f60d43680bda39a3a7c000006.html#a48b5d61f60d43680bda39a3a7c000006">touchgfx::TouchController::sampleTouch</a> and coordinates are translated into click and drag events internally.</p>
<p><br />
 The <a href="http://www.lioonn.com/upload/ST1232_datasheet_v1.0.pdf">Sitronix ST1232 Touch controller</a> <code>include/platform/driver/touch/ST1232TouchController.hpp</code> is a type of <a class="el" href="classtouchgfx_1_1_i2_c_touch_controller.html">touchgfx::I2CTouchController</a> used on a number of boards supported by TouchGFX. It takes an MCU specific I2C driver implementation as argument, as well as the height and width of the display. Specifying an additional correction type will after-process the coordinates read from the touch controller. The ST1232 touch controller provides two methods of correcting/altering the coordinates read from the registers of the touch controller.</p>
<ul>
<li>Transformation by type ("Flip X" and "Flip Y")</li>
<li>User defined transformation</li>
</ul>
<p>For type transformation, the driver supplies the following types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line">{</div>
<div class="line">  NO_TRANSFORM = 0,</div>
<div class="line">  FLIP_X_AXIS,</div>
<div class="line">  FLIP_Y_AXIS</div>
<div class="line">} TransformationType;</div>
</div><!-- fragment --><p><br />
 The following snippet initializes an I2C driver for NXPs LPC43XX series and returns coordinates flipped around the X axis to offset native. Users must make sure that appropriate coordinates are read back to TouchGFX HAL. (calls <code>sampletouch()</code>).</p>
<div class="fragment"><div class="line">I2C_LPC43xx i2c(0);                                     <span class="comment">//Initialize I2c channel 0</span></div>
<div class="line">ST1232TouchController tc(i2c, 480, 272, FLIP_X_AXIS);   <span class="comment">//Initialize touch controller with i2c driver, and native display dimensions. Default transformation is NO_TRANSFORM</span></div>
</div><!-- fragment --><p><br />
 If instead we'd like to perform a custom transformation that does the same thing as FLIP_X_AXIS, the ST1232 touch controller contains a function definition as follows that allow users to define function pointers and manipulate coordinate data before it's returned to TouchGFX HAL. The code also shows how to the custom transformation for FLIP_Y_AXIS.</p>
<div class="fragment"><div class="line"><span class="comment">//Function definition for touch correction </span></div>
<div class="line"><span class="keyword">typedef</span> void (*TransformFuncPtr)(int32_t&amp;, int32_t&amp;, Finger&amp;);</div>
</div><!-- fragment --><p><br />
 In our board configuration, we'd then define our own transformation function as follows, making appropriate calculations based on screen dimensions (in this case 480 x 270).</p>
<div class="fragment"><div class="line"><span class="comment">/* Callback function used for applying a correction strategy to mis-aligned touch coordinates */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> applyTransformation(int32_t&amp; x, int32_t&amp; y, Finger&amp; f)</div>
<div class="line">{</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// X-axis flipped</span></div>
<div class="line">  <span class="comment">/****************************************</span></div>
<div class="line"><span class="comment">   * (0,272)                      (480,272)</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">                 </span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">   * (0,0)                          (480,0)</span></div>
<div class="line"><span class="comment">                                         */</span></div>
<div class="line">   y = 272 - f.y; </div>
<div class="line">   </div>
<div class="line">  <span class="comment">/*******************************/</span></div>
<div class="line">  <span class="comment">/* Other linear permutations */</span></div>
<div class="line">  <span class="comment">/*******************************/</span></div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Y-axis flipped</span></div>
<div class="line">  <span class="comment">/****************************************</span></div>
<div class="line"><span class="comment">   * (480,0)                          (0,0)</span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">                 </span></div>
<div class="line"><span class="comment">    </span></div>
<div class="line"><span class="comment">   * (480,272)                      (0,272)</span></div>
<div class="line"><span class="comment">                                         */</span></div>
<div class="line">   <span class="comment">//x = 480 - f.x    </span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 And on our touchcontroller we'd then set the callback method to our custom method. </p><div class="fragment"><div class="line">tc.setTransformCallback(applyTransformation);</div>
</div><!-- fragment --><h2><a class="anchor" id="sect_overview_platform_hal"></a>
HAL</h2>
<p>The <code>hal</code> folder contains MCU specific TouchGFX ports primarily related to LCD- and DMA controller setup. The general structure for each folder under <code>hal/mcu</code> follows this general set of rules:</p>
<ul>
<li><code>driver</code> contains MCU specific drivers (e.g. I2C drivers) that can be used in conjunction with touch controller drivers. As we saw previously, we could use MCU specific I2C drivers to plug into existing touch controllers like the Sitronix ST1232/1233</li>
<li><code>vendor</code> contains vendor supplied code for the MCU</li>
<li><code>{MCU_ID}DMA.hpp</code> contains the DMA implementation for the MCU (See <a class="el" href="page_porting.html">Porting Guide</a>)</li>
<li><code>{MCU_ID}HAL.hpp</code> contains the HAL implementation for the MCU (See <a class="el" href="page_porting.html">Porting Guide</a>)</li>
</ul>
<pre class="fragment">+-- {mcu vendor}
|     \-- mcu
|         +-- {MCU_ID}
|         |      +-- driver      
|         |      |-- vendor\
|         |      |-- {MCU_ID}DMA.hpp           
|         |      \-- {MCU_ID}HAL.hpp      
</pre><p><br />
 The MCU packages (HAL, DMA) that are preinstalled with TouchGFX can be seen in the following table, which also lists the evaluation boards that use a specific MCU package.</p>
<table class="doxtable">
<tr>
<th>Package Name </th><th>MCUs Supported </th><th>Compilers </th><th>Evaluation Boards  </th></tr>
<tr>
<td>NXP1788 </td><td>LPC1788 </td><td>IAR, GCC </td><td>FDI uEZGUI-1788-70WVT  </td></tr>
<tr>
<td>NXP18xx </td><td>LPC1857 </td><td>IAR, GCC </td><td>None  </td></tr>
<tr>
<td>NXP43xx </td><td>LPC4350,LPC4353,LPC4357 </td><td>IAR, KEIL, GCC </td><td>TouchGFX demo board 4.3", Flashless, 7.0", LPC4357DevKit  </td></tr>
<tr>
<td>STM32F4x9 </td><td>STM32F429, STM32F439 </td><td>IAR, GCC </td><td>ST STM32429I-EVAL1, STM324x9I-EVAL-5.7, STM32F429I-DISCO  </td></tr>
<tr>
<td>FreescaleK70 </td><td>Freescale K70 </td><td>IAR </td><td>None  </td></tr>
</table>
<h1><a class="anchor" id="sect_build_configurations"></a>
Target Configurations</h1>
<p>Functioning TouchGFX buildconfiguration for specific targets require a number of things outlined in the table below.</p>
<table class="doxtable">
<tr>
<th>Resonsibility </th><th>Artifact  </th></tr>
<tr>
<td>Code that initializes OS </td><td>target/main.cpp  </td></tr>
<tr>
<td>Hardware initialization code </td><td>Boardpackage  </td></tr>
<tr>
<td>Software initialization code </td><td>Boardpackage  </td></tr>
</table>
<p><br />
 Remembering what we learned from <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_os">RT Operating System (touchgfx/os/)</a> and <a class="el" href="page_the_touchgfx_distribution.html#sect_touchgfx_dist_board">Board Packages (touchgfx/board/)</a> and keeping in mind the requirements above we can now initialize software, hardware and OS in a single, target-independent file, <code>main.cpp</code>. The code is identical to the other example applications because the requirement to stack size is the same for all applications.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/HAL.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/BoardConfiguration.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetouchgfx.html">touchgfx</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Kernel includes. */</span> </div>
<div class="line"><span class="preprocessor">#include &quot;FreeRTOS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;task.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;queue.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define configGUI_TASK_PRIORITY                 ( tskIDLE_PRIORITY + 3 )</span></div>
<div class="line"><span class="preprocessor">#define configGUI_TASK_STK_SIZE                 ( 950 )</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//Define GUI task</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> GUITask(<span class="keywordtype">void</span>* params) </div>
<div class="line">{ </div>
<div class="line">  <a class="code" href="classtouchgfx_1_1_h_a_l_a9851dbb1edc99dbbe6ee5b876f79b40f.html#a9851dbb1edc99dbbe6ee5b876f79b40f">touchgfx::HAL::getInstance</a>()-&gt;<a class="code" href="classtouchgfx_1_1_h_a_l_a8314deacb6e9d3bdd50e3b89eb09cbd6.html#a8314deacb6e9d3bdd50e3b89eb09cbd6">taskEntry</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>) </div>
<div class="line">{</div>
<div class="line">  <span class="comment">//Initialize TouchGFX and Hardware</span></div>
<div class="line">  <a class="code" href="namespacetouchgfx_acf938165e604a675fe09218a1b3cfb5f.html#acf938165e604a675fe09218a1b3cfb5f">hw_init</a>();</div>
<div class="line">  <a class="code" href="namespacetouchgfx_ae6e21dbb033844e61723026bf9b9a4ad.html#ae6e21dbb033844e61723026bf9b9a4ad">touchgfx_init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Create task</span></div>
<div class="line">  xTaskCreate( GUITask, (<span class="keywordtype">signed</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;GUITask&quot;</span>,</div>
<div class="line">               configGUI_TASK_STK_SIZE,</div>
<div class="line">               NULL,</div>
<div class="line">               configGUI_TASK_PRIORITY,</div>
<div class="line">               NULL);</div>
<div class="line">  </div>
<div class="line">  vTaskStartScheduler();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span>(;;);</div>
<div class="line">} </div>
</div><!-- fragment --><p><br />
 IAR and GCC buildconfigurations, for all or some target boards, are already provided for all TouchGFX applications and utilize one of the available boardpackages for any hardware target specified. An IAR workspace would include the files of both board and OS packages for compilation. The image below shows an IAR configuration that embodies the three responsibilities outlined above.</p>
<div class="image">
<img src="IAR_OS_Board_includes.png" alt="IAR_OS_Board_includes.png"/>
<div class="caption">
IAR Build Configuration</div></div>
<p><br />
<br />
 For a more complete overview of how a project is put together, refer to one of the IAR (<code></code>.eww) workspace files or one of the GCC buildfiles. Take note of how each build configuration makes use of compiler and target specific (Cortex-M3 / Cortex-M4F) portable code.</p>
<h1><a class="anchor" id="sect_adv_monochrome"></a>
Configuring TouchGFX for 1BPP Monochrome</h1>
<p>The default behavior of TouchGFX is to represent graphics in 16 bit RGB565 format. It does, however, come with built in support for monochrome, 1 bit per pixel user interfaces. When running in this mode, the frame buffer(s) only take up one sixteenth of the space required for the RGB565 color format. Likewise, all the generated image data also only take up one bit per pixel. Therefore it is quite likely that 1BPP applications can run on devices with no external memories by having the frame buffer in internal RAM and the image data in internal flash. In order to configure TouchGFX for 1BPP operation, the following needs to be done:</p>
<h2><a class="anchor" id="sect_adv_mono_assets"></a>
1BPP Asset Generation</h2>
<p>Both image data and fonts must be generated in a 1BPP format in order to be displayed properly when running in 1BPP mode. </p>
<h3><a class="anchor" id="sect_adv_mono_Image"></a>
Image Data</h3>
<p>In order to make the image converter output data in 1BPP format, simply modify the config/gcc/app.mk file in your application to specify this </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Settings for image converter output format</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;opaque_image_format := BW</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;non_opaque_image_format := BW</div>
</div><!-- fragment --><p>And likewise for Visual Studio in the config/msvs/Application.props file, if using Visual Studio to generate assets.</p>
<p>This will cause the image converter to output image data in 1BPP. The .png/.bmp image files used as input for the converter must still be in regular 24bpp format. The image converter itself will do the downscaling to monochrome. If the bitmap contains colored pixels (not just black or white), the resulting output will be based on the luminance of the pixel.</p>
<h3><a class="anchor" id="sect_adv_mono_rle"></a>
Compressed Bitmaps</h3>
<p>Monochrome images can alternatively be stored in a horizontal run-length encoded format. This will in many cases substantially reduce the amount of flash memory each image takes up, and is therefore worth investigating if flash memory is scarce. If compression is enabled, the imageconverter will automatically calculate the resulting size for each bitmap and only use the run-length encoded format if the size is smaller than the normal unpacked format. Therefore, run-length encoding has a worst case size equal to that of uncompressed bitmaps. The drawback to using compression is that the rendering speed will decrease somewhat for compressed bitmaps because the format must be decoded by TouchGFX before drawing. You must therefore decide this tradeoff for your specific application based on your requirements. In order to enable bitmap compression, use the image format BW_RLE instead of BW: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Settings for image converter output format</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;opaque_image_format := BW_RLE</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;non_opaque_image_format := BW_RLE</div>
</div><!-- fragment --><h3><a class="anchor" id="sect_adv_mono_font"></a>
Font Data</h3>
<p>In order to specify the use of 1BPP fonts, simply modify all typographies used in the Texts.xlsx Excel sheet to use 1 bit per pixel.</p>
<h2><a class="anchor" id="sect_adv_mono_boardconfig"></a>
Board Configuration</h2>
<p>The BoardConfiguration.cpp for the appropriate target hardware (or simulator/main.cpp for PC simulator) file must be changed to use a 1-bit LCD object instead of the standard 16-bit type: </p><div class="fragment"><div class="line"><span class="comment">//LCD16bpp display;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Monochrome 1BPP mode</span></div>
<div class="line">LCD1bpp display;</div>
</div><!-- fragment --><p>Finally, on target only, the <a class="el" href="classtouchgfx_1_1_h_a_l_ab6cb18edd347470dda687d7c13dae035.html#ab6cb18edd347470dda687d7c13dae035">setFrameBufferStartAddress</a> function must be modified to inform the framework that the frame buffer(s) should use a bit depth of 1: </p><div class="fragment"><div class="line">hal.setFrameBufferStartAddress((uint16_t*)SDRAM_BASE, 1);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The use of DMA to transfer graphics data is not supported in 1BPP mode. You can change your DMA object in BoardConfiguration to be of type <a class="el" href="classtouchgfx_1_1_no_d_m_a.html">NoDMA</a> for clarity, but the DMA object is ignored entirely in 1BPP mode.</dd></dl>
<p>With the changes above, your application now runs in 1BPP mode. This does not impact the API or features of TouchGFX compared to 16bit mode except in one area: alpha blending is ignored since it does not really make sense in a 1BPP context. There are some instances where colors are expressed in uint16_t (for instance in TextArea or Box widgets). In those cases, a value of zero is interpreted as black, where as any other value is interpreted as white.</p>
<p>See <a class="el" href="page_examples.html#sect_monochrome_example">Monochrome Example</a> for an example configured for 1BPP mode.</p>
<h1><a class="anchor" id="sect_adv_display_orientation"></a>
Switching Display Orientation</h1>
<p>Most TFT displays is built for either landscape or portrait orientation. That is, the display will have a fixed starting point where the first pixel value received from the TFT controller is placed, and a fixed direction in which the following pixels are placed. Some displays are configurable in terms of this but that is not necessarily the case. In order to support both landscape and portrait orientation for user interfaces, TouchGFX has a built-in mechanism for rotating the UI such that e.g. a portrait UI can be realized on a display that natively runs in landscape mode. This rotation is applied at no performance cost so rendering times are not increased if your UI design does not match the native orientation of the display.</p>
<div class="image">
<img src="landscape-portrait.png" alt="landscape-portrait.png"/>
<div class="caption">
Example UI in landscape and portrait orientation</div></div>
<br />
In order to achieve this, TouchGFX must be informed of what the <em>native</em> orientation of the display itself is. This is done in the <a class="el" href="page_porting.html#sect_basic_boardconfig">BoardConfiguration</a>, where the hardware abstraction layer is informed of the width and height of the display in pixels. If the width is larger than the height, the native orientation is inferred to be landscape.</p>
<p>If the user interface you are implementing has the same display orientation as your actual TFT display has, nothing special needs to be done since the default behavior is to match the orientation of the display itself. If, however, your UI is e.g. portrait and your display is landscape, you need explicitly change orientation at runtime by calling the function </p><div class="fragment"><div class="line"><span class="comment">//Switch to portrait mode.</span></div>
<div class="line">HAL::getInstance()-&gt;setDisplayOrientation(ORIENTATION_PORTRAIT); </div>
</div><!-- fragment --><p>If your entire application uses the same orientation throughout, it is easiest to change the display orientation before the GUI task starts so you do not have to worry about it in your views. If your application supports both, please see <a class="el" href="page_advanced.html#sect_adv_display_orientation_dynamically">Dynamic Switching at Runtime (supporting both orientations)</a>.</p>
<p>The necessary coordinate transformations take place behind the scenes. The width and height of the root Container of your view, touch input coordinates, and widget coordinates are all expressed in the coordinate space denoted by your chosen display orientation for the user interface. As such, there is really only one thing an application developer needs to be concerned with regarding display orientation, and that relates to bitmaps and is described in the following section.</p>
<h2><a class="anchor" id="sect_adv_display_orientation_bitmaps"></a>
Graphics Data in a Non-Native User Interface Orientation</h2>
<p>If the orientation of your user interface is different from the native orientation of the TFT display, all graphics data must be generated with a specific flag. This will cause the binary pixel data to be represented in a different format on the target, which is what allows TouchGFX to render a rotated display without performance overhead. When configuring your project it is therefore necessary to know whether UI orientation differs from the native orientation. If that is the case, modify the config/gcc/app.mk to specify the following: </p><div class="fragment"><div class="line"><span class="preprocessor"># Settings for image converter screen orientation (empty string = default value, -rotate90 rotates the image 90 degrees)</span></div>
<div class="line"><span class="preprocessor">screen_orientation := -rotate90</span></div>
</div><!-- fragment --><p>And likewise for config/msvc/Application.props if using Visual Studio to generate assets:</p>
<div class="fragment"><div class="line">&lt;RotateImage90&gt;<span class="keyword">true</span>&lt;/RotateImage90&gt;</div>
</div><!-- fragment --><p>To summarize, the rotate90 flag must be applied to your asset generation if one of the following is true</p><ul>
<li>Your application is in portrait mode and the display is natively in landscape mode, or</li>
<li>Your application is in landscape mode and the display is natively in portrait mode</li>
</ul>
<h2><a class="anchor" id="sect_adv_display_orientation_dynamically"></a>
Dynamic Switching at Runtime (supporting both orientations)</h2>
<p>This subsection only applies in the case where your application must be able to dynamically switch between portrait and landscape mode at runtime, for instance if the device is equipped with an accelerometer to detect rotation change. If both orientations are to be supported, then the bitmaps that are to be displayed in the orientation matching the native display orientation must be generated without rotation, whereas the bitmaps to display in the non-native orientation must be generated with the -rotate90 option. In order to achieve this, the TouchGFX asset generation mechanism has built in support for a per-bitmap setting of rotation instead of the global -rotate flags. Therefore, when having both orientations present, set the screen_orientation variable to an empty string (or -rotate0). We then need to override this setting for the bitmaps in non-native orientation, e.g. portrait bitmaps on a native landscape display. TouchGFX has a naming convention regarding bitmaps which means that the orientation can be overridden from the global setting by including ".90." in the file name, such that for instance a bitmap called </p><pre class="fragment">icon.90.png
</pre><p> will be generated with the -rotate90 switch automatically.</p>
<h3><a class="anchor" id="sect_adv_display_orientation_dynamically_switch"></a>
Performing the Switch</h3>
<p>Because the root container of your view must be changed to the new dimensions when switching orientation, it is necessary to perform a screen transition after switching orientation. This transition can either be to a different view/presenter, or to the same view/presenter as being currently displayed. For instance: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gui/common/FrontendApplication.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;touchgfx/hal/HAL.hpp&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> MyView::performOrientationChange(DisplayOrientation orientation)</div>
<div class="line">{</div>
<div class="line">  HAL::getInstance()-&gt;setDisplayOrientation(orientation); <span class="comment">//set new orientation</span></div>
<div class="line">  <span class="keyword">static_cast&lt;</span>FrontendApplication*<span class="keyword">&gt;</span>(Application::getInstance())-&gt;gotoMyScreen(); <span class="comment">//switch screen (to the same screen we are currently displaying).</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Whether or not to reuse the same screen for both orientations or to create landscape and portrait versions of a screen primarily depends on the amount of differences between the two. Usually it is only widget coordinates and bitmap IDs that differ, and therefore it is easier to use the same view/presenter and simply testing for current orientation in the setupScreen function, like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyView::setupScreen()</div>
<div class="line">{</div>
<div class="line">  bg.setXY(0, 0);</div>
<div class="line">  <span class="keywordflow">if</span> (HAL::getInstance()-&gt;getDisplayOrientation() == ORIENTATION_LANDSCAPE)</div>
<div class="line">  {</div>
<div class="line">    bg.setBItmap(BITMAP_BG_ID);</div>
<div class="line">    icon.setBitmap(BITMAP_ICON_ID);</div>
<div class="line">    icon.setXY(200, 20);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="comment">//Portrait</span></div>
<div class="line">  {</div>
<div class="line">    bg.setBItmap(BITMAP_BG_90_ID);</div>
<div class="line">    icon.setBitmap(BITMAP_ICON_90_ID);</div>
<div class="line">    icon.setXY(40, 30);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  add(bg);</div>
<div class="line">  add(icon);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that in the example above, the native orientation is landscape which means that the bitmaps used in portrait mode have been suffixed with .90. as mentioned earlier. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
